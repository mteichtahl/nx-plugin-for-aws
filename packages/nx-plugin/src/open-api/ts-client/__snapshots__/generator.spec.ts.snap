// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by tag 1`] = `
"export type ListError = never;
export type List0Error = never;
"
`;

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by tag 2`] = `
"
/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  private _list = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/items', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  private _list_0 = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/users', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  /**
   * items operations
   */
  public items = {
    list: this._list,
  };

  /**
   * users operations
   */
  public users = {
    list: this._list_0,
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for arrays and dictionaries 1`] = `
"export type PostTest200ResponseItem = {
  id: string;
  tags?: Array<string>;
};
export type PostTestRequestContent = {
  stringArray?: Array<string>;
  numberArray?: Array<number>;
  stringDict?: { [key: string]: string; };
  complexDict?: { [key: string]: PostTestRequestContentComplexDictValue; };
};
export type PostTestRequestContentComplexDictValue = {
  name: string;
  value: number;
};

export type PostTestRequest = PostTestRequestContent | undefined;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for arrays and dictionaries 2`] = `
"import type {
  PostTest200ResponseItem,
  PostTestRequestContent,
  PostTestRequestContentComplexDictValue,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200ResponseItem = {
    toJson: (model: PostTest200ResponseItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined ? {} : {
          'id': model.id,
        }),
        ...(model.tags === undefined ? {} : {
          'tags': model.tags,
        }),
      };
    },
    fromJson: (json: any): PostTest200ResponseItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        ...(json['tags'] === undefined ? {} : {
          tags: json['tags'],
        }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.stringArray === undefined ? {} : {
          'stringArray': model.stringArray,
        }),
        ...(model.numberArray === undefined ? {} : {
          'numberArray': model.numberArray,
        }),
        ...(model.stringDict === undefined ? {} : {
          'stringDict': model.stringDict,
        }),
        ...(model.complexDict === undefined ? {} : {
          'complexDict': ($IO.mapValues(model.complexDict, $IO.PostTestRequestContentComplexDictValue.toJson)),
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['stringArray'] === undefined ? {} : {
          stringArray: json['stringArray'],
        }),
        ...(json['numberArray'] === undefined ? {} : {
          numberArray: json['numberArray'],
        }),
        ...(json['stringDict'] === undefined ? {} : {
          stringDict: json['stringDict'],
        }),
        ...(json['complexDict'] === undefined ? {} : {
          complexDict: ($IO.mapValues(json['complexDict'], $IO.PostTestRequestContentComplexDictValue.fromJson)),
        }),
      };
    },
  };

  public static PostTestRequestContentComplexDictValue = {
    toJson: (model: PostTestRequestContentComplexDictValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined ? {} : {
          'name': model.name,
        }),
        ...(model.value === undefined ? {} : {
          'value': model.value,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContentComplexDictValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postTest = async (input?: PostTestRequest): Promise<Array<PostTest200ResponseItem>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostTestRequestContent.toJson(input)) : String($IO.PostTestRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return (await response.json()).map($IO.PostTest200ResponseItem.fromJson);
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for composite types 1`] = `
"export type PutTest200Response = PutTest200ResponseAllOf & PutTest200ResponseAllOf1;
export type PutTest200ResponseAllOf = {
  id: string;
};
export type PutTest200ResponseAllOf1 = {
  metadata?: PutTest200ResponseAllOf1Metadata;
};
export type PutTest200ResponseAllOf1Metadata = {
  created?: Date;
};
export type PutTestRequestContent = PutTestRequestContentOneOf | PutTestRequestContentOneOf1;
export type PutTestRequestContentOneOf = {
  type: PutTestRequestContentOneOfType;
  valueA: string;
};
export type PutTestRequestContentOneOf1 = {
  type: PutTestRequestContentOneOf1Type;
  valueB: number;
};
export type PutTestRequestContentOneOf1Type =
  | 'b'
export type PutTestRequestContentOneOfType =
  | 'a'

export type PutTestRequest = PutTestRequestContent | undefined;
export type PutTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for composite types 2`] = `
"import type {
  PutTest200Response,
  PutTest200ResponseAllOf,
  PutTest200ResponseAllOf1,
  PutTest200ResponseAllOf1Metadata,
  PutTestRequestContent,
  PutTestRequestContentOneOf,
  PutTestRequestContentOneOf1,
  PutTestRequestContentOneOf1Type,
  PutTestRequestContentOneOfType,
  PutTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PutTest200Response = {
    toJson: (model: PutTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.toJson(model),
        ...$IO.PutTest200ResponseAllOf1.toJson(model),
      };
    },
    fromJson: (json: any): PutTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.fromJson(json),
        ...$IO.PutTest200ResponseAllOf1.fromJson(json),
      };
    },
  };

  public static PutTest200ResponseAllOf = {
    toJson: (model: PutTest200ResponseAllOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined ? {} : {
          'id': model.id,
        }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
      };
    },
  };

  public static PutTest200ResponseAllOf1 = {
    toJson: (model: PutTest200ResponseAllOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.metadata === undefined ? {} : {
          'metadata': $IO.PutTest200ResponseAllOf1Metadata.toJson(model.metadata),
        }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['metadata'] === undefined ? {} : {
          metadata: $IO.PutTest200ResponseAllOf1Metadata.fromJson(json['metadata']),
        }),
      };
    },
  };

  public static PutTest200ResponseAllOf1Metadata = {
    toJson: (model: PutTest200ResponseAllOf1Metadata): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.created === undefined ? {} : {
          'created': (model.created.toISOString()),
        }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1Metadata => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['created'] === undefined ? {} : {
          created: (new Date(json['created'])),
        }),
      };
    },
  };

  public static PutTestRequestContent = {
    toJson: (model: PutTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.toJson(model as PutTestRequestContentOneOf),
        ...$IO.PutTestRequestContentOneOf1.toJson(model as PutTestRequestContentOneOf1),
      };
    },
    fromJson: (json: any): PutTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.fromJson(json),
        ...$IO.PutTestRequestContentOneOf1.fromJson(json),
      };
    },
  };

  public static PutTestRequestContentOneOf = {
    toJson: (model: PutTestRequestContentOneOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined ? {} : {
          'type': model.type,
        }),
        ...(model.valueA === undefined ? {} : {
          'valueA': model.valueA,
        }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueA: json['valueA'],
      };
    },
  };

  public static PutTestRequestContentOneOf1 = {
    toJson: (model: PutTestRequestContentOneOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined ? {} : {
          'type': model.type,
        }),
        ...(model.valueB === undefined ? {} : {
          'valueB': model.valueB,
        }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueB: json['valueB'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public putTest = async (input?: PutTestRequest): Promise<PutTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PutTestRequestContent.toJson(input)) : String($IO.PutTestRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'PUT',
      body,
    });

    if (response.status === 200) {
      return $IO.PutTest200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for parameters and responses 1`] = `
"export type GetTest200Response = {
  result?: string;
};
export type GetTest400Response = {
  error?: string;
};
export type GetTestRequestHeaderParameters = {
  xApiKey: string;
};
export type GetTestRequestPathParameters = {
  id: string;
};
export type GetTestRequestQueryParameters = {
  filter?: string;
  tags?: Array<string>;
};

export type GetTestRequest = GetTestRequestPathParameters & GetTestRequestHeaderParameters & GetTestRequestQueryParameters;
export type GetTest400Error = {
  status: 400;
  error: GetTest400Response;
};
export type GetTest404Error = {
  status: 404;
  error: void;
};
export type GetTestError = GetTest400Error | GetTest404Error;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for parameters and responses 2`] = `
"import type {
  GetTest200Response,
  GetTest400Response,
  GetTestRequestHeaderParameters,
  GetTestRequestPathParameters,
  GetTestRequestQueryParameters,
  GetTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined ? {} : {
          'result': model.result,
        }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined ? {} : {
          result: json['result'],
        }),
      };
    },
  };

  public static GetTest400Response = {
    toJson: (model: GetTest400Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined ? {} : {
          'error': model.error,
        }),
      };
    },
    fromJson: (json: any): GetTest400Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['error'] === undefined ? {} : {
          error: json['error'],
        }),
      };
    },
  };

  public static GetTestRequestHeaderParameters = {
    toJson: (model: GetTestRequestHeaderParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.xApiKey === undefined ? {} : {
          'x-api-key': model.xApiKey,
        }),
      };
    },
    fromJson: (json: any): GetTestRequestHeaderParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        xApiKey: json['x-api-key'],
      };
    },
  };

  public static GetTestRequestPathParameters = {
    toJson: (model: GetTestRequestPathParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined ? {} : {
          'id': model.id,
        }),
      };
    },
    fromJson: (json: any): GetTestRequestPathParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
      };
    },
  };

  public static GetTestRequestQueryParameters = {
    toJson: (model: GetTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': model.filter,
        }),
        ...(model.tags === undefined ? {} : {
          'tags': model.tags,
        }),
      };
    },
    fromJson: (json: any): GetTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined ? {} : {
          filter: json['filter'],
        }),
        ...(json['tags'] === undefined ? {} : {
          tags: json['tags'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public getTest = async (input: GetTestRequest): Promise<GetTest200Response> => {
    const pathParameters = $IO.GetTestRequestPathParameters.toJson(input);
    const queryParameters = $IO.GetTestRequestQueryParameters.toJson(input);
    const headerParameters = $IO.GetTestRequestHeaderParameters.toJson(input);
    const collectionFormats = {
      'x-api-key': 'csv',
      'filter': 'multi',
      'tags': 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(this.$url('/test/{id}', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.GetTest400Response.fromJson(await response.json()),
      };
    }
    if (response.status === 404) {
      throw {
        status: response.status,
      };
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for primitive types 1`] = `
"export type GetTest200Response = {
  string: string;
  number: number;
  integer: number;
  boolean: boolean;
  nullableString?: string | null;
  optionalNumber?: number;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for primitive types 2`] = `
"import type {
  GetTest200Response,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.string === undefined ? {} : {
          'string': model.string,
        }),
        ...(model.number === undefined ? {} : {
          'number': model.number,
        }),
        ...(model.integer === undefined ? {} : {
          'integer': model.integer,
        }),
        ...(model.boolean === undefined ? {} : {
          'boolean': model.boolean,
        }),
        ...(model.nullableString === undefined ? {} : {
          'nullable-string': model.nullableString,
        }),
        ...(model.optionalNumber === undefined ? {} : {
          'optionalNumber': model.optionalNumber,
        }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        string: json['string'],
        number: json['number'],
        integer: json['integer'],
        boolean: json['boolean'],
        ...(json['nullable-string'] === undefined ? {} : {
          nullableString: json['nullable-string'] === null ? null : json['nullable-string'],
        }),
        ...(json['optionalNumber'] === undefined ? {} : {
          optionalNumber: json['optionalNumber'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  /**
   * Sends a test request!
   */
  public getTest = async (): Promise<GetTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle composite primitive and array request bodies 1`] = `
"export type CompositeRequestContent = string | number | boolean | Array<string> | Array<CompositeRequestContentOneOf1Item> | { [key: string]: number; } | { [key: string]: CompositeRequestContentOneOf3Value; } | CompositeRequestContentOneOf4;
export type CompositeRequestContentOneOf1Item = {
  a?: string;
};
export type CompositeRequestContentOneOf3Value = {
  a?: string;
};
export type CompositeRequestContentOneOf4 = null | {
  key?: string;
};

export type CompositeRequest = CompositeRequestContent | undefined;
export type CompositeError = never;
"
`;

exports[`openApiTsClientGenerator > should handle composite primitive and array request bodies 2`] = `
"import type {
  CompositeRequestContent,
  CompositeRequestContentOneOf1Item,
  CompositeRequestContentOneOf3Value,
  CompositeRequestContentOneOf4,
  CompositeRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static CompositeRequestContent = {
    toJson: (model: CompositeRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === "string") {
          return model;
      }
      if (typeof model === "number") {
          return model;
      }
      if (typeof model === "boolean") {
          return model;
      }
      if (Array.isArray(model) && (model.length === 0 || typeof model[0] !== 'object')) {
          return model;
      }
      if (Array.isArray(model) && (model.length === 0 || typeof model[0] === 'object')) {
          return model === null ? null : (model.map($IO.CompositeRequestContentOneOf1Item.toJson));
      }
      return {
        ...model === null ? null : model,
        ...model === null ? null : ($IO.mapValues(model, $IO.CompositeRequestContentOneOf3Value.toJson)),
        ...$IO.CompositeRequestContentOneOf4.toJson(model as CompositeRequestContentOneOf4),
      };
    },
    fromJson: (json: any): CompositeRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === "string") {
          return json;
      }
      if (typeof json === "number") {
          return json;
      }
      if (typeof json === "boolean") {
          return json;
      }
      if (Array.isArray(json) && (json.length === 0 || typeof json[0] !== 'object')) {
          return json;
      }
      if (Array.isArray(json) && (json.length === 0 || typeof json[0] === 'object')) {
          return json === null ? null : ((json as Array<any>).map($IO.CompositeRequestContentOneOf1Item.fromJson));
      }
      return {
        ...json === null ? null : json,
        ...json === null ? null : ($IO.mapValues(json, $IO.CompositeRequestContentOneOf3Value.fromJson)),
        ...$IO.CompositeRequestContentOneOf4.fromJson(json),
      };
    },
  };

  public static CompositeRequestContentOneOf1Item = {
    toJson: (model: CompositeRequestContentOneOf1Item): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined ? {} : {
          'a': model.a,
        }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf1Item => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined ? {} : {
          a: json['a'],
        }),
      };
    },
  };

  public static CompositeRequestContentOneOf3Value = {
    toJson: (model: CompositeRequestContentOneOf3Value): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined ? {} : {
          'a': model.a,
        }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf3Value => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined ? {} : {
          a: json['a'],
        }),
      };
    },
  };

  public static CompositeRequestContentOneOf4 = {
    toJson: (model: CompositeRequestContentOneOf4): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined ? {} : {
          'key': model.key,
        }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf4 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined ? {} : {
          key: json['key'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public composite = async (input?: CompositeRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.CompositeRequestContent.toJson(input)) : String($IO.CompositeRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/composite', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle date and date-time formats 1`] = `
"export type PostDates200Response = {
  processedDate?: Date;
  processedDateTime?: Date;
};
export type PostDatesRequestContent = {
  dateOnly: Date;
  dateTime: Date;
  dateArray?: Array<Date>;
  dateTimeArray?: Array<Date>;
};

export type PostDatesRequest = PostDatesRequestContent | undefined;
export type PostDatesError = never;

export type PostSingleDateRequest = Date;
export type PostSingleDateError = never;
"
`;

exports[`openApiTsClientGenerator > should handle date and date-time formats 2`] = `
"import type {
  PostDates200Response,
  PostDatesRequestContent,
  PostDatesRequest,
  PostSingleDateRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostDates200Response = {
    toJson: (model: PostDates200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.processedDate === undefined ? {} : {
          'processedDate': (model.processedDate.toISOString().slice(0,10)),
        }),
        ...(model.processedDateTime === undefined ? {} : {
          'processedDateTime': (model.processedDateTime.toISOString()),
        }),
      };
    },
    fromJson: (json: any): PostDates200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['processedDate'] === undefined ? {} : {
          processedDate: (new Date(json['processedDate'])),
        }),
        ...(json['processedDateTime'] === undefined ? {} : {
          processedDateTime: (new Date(json['processedDateTime'])),
        }),
      };
    },
  };

  public static PostDatesRequestContent = {
    toJson: (model: PostDatesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.dateOnly === undefined ? {} : {
          'dateOnly': (model.dateOnly.toISOString().slice(0,10)),
        }),
        ...(model.dateTime === undefined ? {} : {
          'dateTime': (model.dateTime.toISOString()),
        }),
        ...(model.dateArray === undefined ? {} : {
          'dateArray': (model.dateArray.map((item0) => item0.toISOString().slice(0,10))),
        }),
        ...(model.dateTimeArray === undefined ? {} : {
          'dateTimeArray': (model.dateTimeArray.map((item0) => item0.toISOString())),
        }),
      };
    },
    fromJson: (json: any): PostDatesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        dateOnly: (new Date(json['dateOnly'])),
        dateTime: (new Date(json['dateTime'])),
        ...(json['dateArray'] === undefined ? {} : {
          dateArray: ((json['dateArray'] as Array<any>).map((item0) => new Date(item0))),
        }),
        ...(json['dateTimeArray'] === undefined ? {} : {
          dateTimeArray: ((json['dateTimeArray'] as Array<any>).map((item0) => new Date(item0))),
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postDates = async (input?: PostDatesRequest): Promise<PostDates200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostDatesRequestContent.toJson(input)) : String($IO.PostDatesRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/dates', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.PostDates200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postSingleDate = async (input: PostSingleDateRequest): Promise<Date> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input.toISOString().slice(0,10);

    const response = await this.$fetch(this.$url('/single-date', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return new Date(await response.text());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle default responses 1`] = `
"export type GetTest200Response = {
  message: string;
};
export type GetTestdefaultResponse = {
  error: string;
};
export type GetTestDefaultError = {
  status: number;
  error: GetTestdefaultResponse;
};
export type GetTestError = GetTestDefaultError;
"
`;

exports[`openApiTsClientGenerator > should handle default responses 2`] = `
"import type {
  GetTest200Response,
  GetTestdefaultResponse,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined ? {} : {
          'message': model.message,
        }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static GetTestdefaultResponse = {
    toJson: (model: GetTestdefaultResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined ? {} : {
          'error': model.error,
        }),
      };
    },
    fromJson: (json: any): GetTestdefaultResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        error: json['error'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public getTest = async (): Promise<GetTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    throw {
      status: response.status,
      error: $IO.GetTestdefaultResponse.fromJson(await response.json()),
    };
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle enum request and response bodies 1`] = `
"export type UpdateStatus200Response =
  | 'accepted'
  | 'rejected'
export type UpdateStatusRequestContent =
  | 'pending'
  | 'in_progress'
  | 'completed'
  | 'failed'

export type UpdateStatusRequest = UpdateStatusRequestContent;
export type UpdateStatusError = never;
"
`;

exports[`openApiTsClientGenerator > should handle enum request and response bodies 2`] = `
"import type {
  UpdateStatus200Response,
  UpdateStatusRequestContent,
  UpdateStatusRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public updateStatus = async (input: UpdateStatusRequest): Promise<UpdateStatus200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input;

    const response = await this.$fetch(this.$url('/status', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return (await response.text()) as UpdateStatus200Response;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle inline primitives and composite schemas 1`] = `
"export type TestArrays200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParameters200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParametersRequestBodyParameters = {
  body?: Array<string>;
};
export type TestArraysWithOtherParametersRequestQueryParameters = {
  someParameter?: string;
};
export type TestComposites200Response = TestComposites200ResponseAnyOf | TestComposites200ResponseAnyOf1;
export type TestComposites200ResponseAnyOf = {
  foo?: string;
};
export type TestComposites200ResponseAnyOf1 = {
  bar?: string;
};
export type TestCompositesRequestContent = TestCompositesRequestContentOneOf | string;
export type TestCompositesRequestContentOneOf =
  | 'a'
  | 'b'
  | 'c'
export type TestEnums200Response =
  | 'pending'
  | 'active'
  | 'completed'

export type TestArraysRequest = Array<string> | undefined;
export type TestArraysError = never;

export type TestArraysWithOtherParametersRequest = TestArraysWithOtherParametersRequestQueryParameters & TestArraysWithOtherParametersRequestBodyParameters;
export type TestArraysWithOtherParametersError = never;

export type TestCompositesRequest = TestCompositesRequestContent | undefined;
export type TestCompositesError = never;
export type TestEnumsError = never;

export type TestPrimitiveBinaryRequest = Blob;
export type TestPrimitiveBinaryError = never;

export type TestPrimitiveTextRequest = string;
export type TestPrimitiveTextError = never;
"
`;

exports[`openApiTsClientGenerator > should handle inline primitives and composite schemas 2`] = `
"import type {
  TestArrays200Response,
  TestArraysWithOtherParameters200Response,
  TestArraysWithOtherParametersRequestBodyParameters,
  TestArraysWithOtherParametersRequestQueryParameters,
  TestComposites200Response,
  TestComposites200ResponseAnyOf,
  TestComposites200ResponseAnyOf1,
  TestCompositesRequestContent,
  TestCompositesRequestContentOneOf,
  TestEnums200Response,
  TestArraysRequest,
  TestArraysWithOtherParametersRequest,
  TestCompositesRequest,
  TestPrimitiveBinaryRequest,
  TestPrimitiveTextRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestArrays200Response = {
    toJson: (model: TestArrays200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArrays200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParameters200Response = {
    toJson: (model: TestArraysWithOtherParameters200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArraysWithOtherParameters200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParametersRequestBodyParameters = {
    toJson: (model: TestArraysWithOtherParametersRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined ? {} : {
          'body': model.body,
        }),
      };
    },
    fromJson: (json: any): TestArraysWithOtherParametersRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined ? {} : {
          body: json['body'],
        }),
      };
    },
  };

  public static TestArraysWithOtherParametersRequestQueryParameters = {
    toJson: (model: TestArraysWithOtherParametersRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.someParameter === undefined ? {} : {
          'someParameter': model.someParameter,
        }),
      };
    },
    fromJson: (json: any): TestArraysWithOtherParametersRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['someParameter'] === undefined ? {} : {
          someParameter: json['someParameter'],
        }),
      };
    },
  };

  public static TestComposites200Response = {
    toJson: (model: TestComposites200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.toJson(model as TestComposites200ResponseAnyOf),
        ...$IO.TestComposites200ResponseAnyOf1.toJson(model as TestComposites200ResponseAnyOf1),
      };
    },
    fromJson: (json: any): TestComposites200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.fromJson(json),
        ...$IO.TestComposites200ResponseAnyOf1.fromJson(json),
      };
    },
  };

  public static TestComposites200ResponseAnyOf = {
    toJson: (model: TestComposites200ResponseAnyOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined ? {} : {
          'foo': model.foo,
        }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined ? {} : {
          foo: json['foo'],
        }),
      };
    },
  };

  public static TestComposites200ResponseAnyOf1 = {
    toJson: (model: TestComposites200ResponseAnyOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.bar === undefined ? {} : {
          'bar': model.bar,
        }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['bar'] === undefined ? {} : {
          bar: json['bar'],
        }),
      };
    },
  };

  public static TestCompositesRequestContent = {
    toJson: (model: TestCompositesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === "string") {
          return model;
      }
      if (typeof model === "string") {
          return model;
      }
      return model;
    },
    fromJson: (json: any): TestCompositesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === "string") {
          return json;
      }
      if (typeof json === "string") {
          return json;
      }
      return json;
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public testArrays = async (input?: TestArraysRequest): Promise<TestArrays200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify(input) : String(input));

    const response = await this.$fetch(this.$url('/arrays', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestArrays200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testArraysWithOtherParameters = async (input: TestArraysWithOtherParametersRequest): Promise<TestArraysWithOtherParameters200Response> => {
    const pathParameters = {};
    const queryParameters = $IO.TestArraysWithOtherParametersRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'someParameter': 'multi',
    } as const;
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(input).body) : String($IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(input).body));

    const response = await this.$fetch(this.$url('/arrays-with-other-parameters', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestArraysWithOtherParameters200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testComposites = async (input?: TestCompositesRequest): Promise<TestComposites200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestCompositesRequestContent.toJson(input)) : String($IO.TestCompositesRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/composites', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestComposites200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testEnums = async (): Promise<TestEnums200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/enums', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return (await response.text()) as TestEnums200Response;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testPrimitiveBinary = async (input: TestPrimitiveBinaryRequest): Promise<Blob> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input;

    const response = await this.$fetch(this.$url('/primitives/binary', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.blob();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testPrimitiveText = async (input: TestPrimitiveTextRequest): Promise<number> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = String(input);

    const response = await this.$fetch(this.$url('/primitives/text', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return Number(await response.text());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle multiple response status codes 1`] = `
"export type TestResponses2XXResponse = {
  result?: string;
};
export type TestResponses500Response = {
  reason?: string;
};
export type TestResponses5XXResponse = {
  error?: string;
  trace?: string;
};
export type TestResponsesRequestContent = {
  data?: string;
};

export type TestResponsesRequest = TestResponsesRequestContent | undefined;
export type TestResponses500Error = {
  status: 500;
  error: TestResponses500Response;
};
export type TestResponses5XXError = {
  status: _5XX;
  error: TestResponses5XXResponse;
};
export type TestResponsesError = TestResponses500Error | TestResponses5XXError;
export type _5XX = 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 509 | 510 | 511 | 512 | 513 | 514 | 515 | 516 | 517 | 518 | 519 | 520 | 521 | 522 | 523 | 524 | 525 | 526 | 527 | 528 | 529 | 530 | 531 | 532 | 533 | 534 | 535 | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 | 544 | 545 | 546 | 547 | 548 | 549 | 550 | 551 | 552 | 553 | 554 | 555 | 556 | 557 | 558 | 559 | 560 | 561 | 562 | 563 | 564 | 565 | 566 | 567 | 568 | 569 | 570 | 571 | 572 | 573 | 574 | 575 | 576 | 577 | 578 | 579 | 580 | 581 | 582 | 583 | 584 | 585 | 586 | 587 | 588 | 589 | 590 | 591 | 592 | 593 | 594 | 595 | 596 | 597 | 598 | 599;
"
`;

exports[`openApiTsClientGenerator > should handle multiple response status codes 2`] = `
"import type {
  TestResponses2XXResponse,
  TestResponses500Response,
  TestResponses5XXResponse,
  TestResponsesRequestContent,
  TestResponsesRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestResponses2XXResponse = {
    toJson: (model: TestResponses2XXResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined ? {} : {
          'result': model.result,
        }),
      };
    },
    fromJson: (json: any): TestResponses2XXResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined ? {} : {
          result: json['result'],
        }),
      };
    },
  };

  public static TestResponses500Response = {
    toJson: (model: TestResponses500Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.reason === undefined ? {} : {
          'reason': model.reason,
        }),
      };
    },
    fromJson: (json: any): TestResponses500Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['reason'] === undefined ? {} : {
          reason: json['reason'],
        }),
      };
    },
  };

  public static TestResponses5XXResponse = {
    toJson: (model: TestResponses5XXResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined ? {} : {
          'error': model.error,
        }),
        ...(model.trace === undefined ? {} : {
          'trace': model.trace,
        }),
      };
    },
    fromJson: (json: any): TestResponses5XXResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['error'] === undefined ? {} : {
          error: json['error'],
        }),
        ...(json['trace'] === undefined ? {} : {
          trace: json['trace'],
        }),
      };
    },
  };

  public static TestResponsesRequestContent = {
    toJson: (model: TestResponsesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.data === undefined ? {} : {
          'data': model.data,
        }),
      };
    },
    fromJson: (json: any): TestResponsesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['data'] === undefined ? {} : {
          data: json['data'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public testResponses = async (input?: TestResponsesRequest): Promise<TestResponses2XXResponse> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestResponsesRequestContent.toJson(input)) : String($IO.TestResponsesRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.TestResponses500Response.fromJson(await response.json()),
      };
    }
    if (response.status >= 200 && response.status < 300) {
      return $IO.TestResponses2XXResponse.fromJson(await response.json());
    }
    if (response.status >= 500 && response.status < 600) {
      throw {
        status: response.status,
        error: $IO.TestResponses5XXResponse.fromJson(await response.json()),
      };
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle not schema type 1`] = `
"export type TestNot200Response = {
  result?: string;
};
export type TestNotRequestContent = {
  notObject?: unknown;
  notString?: unknown;
};
export type TestNotRequestContentNotObjectNot = {
  foo?: string;
};

export type TestNotRequest = TestNotRequestContent | undefined;
export type TestNotError = never;
"
`;

exports[`openApiTsClientGenerator > should handle not schema type 2`] = `
"import type {
  TestNot200Response,
  TestNotRequestContent,
  TestNotRequestContentNotObjectNot,
  TestNotRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestNot200Response = {
    toJson: (model: TestNot200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined ? {} : {
          'result': model.result,
        }),
      };
    },
    fromJson: (json: any): TestNot200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined ? {} : {
          result: json['result'],
        }),
      };
    },
  };

  public static TestNotRequestContent = {
    toJson: (model: TestNotRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.notObject === undefined ? {} : {
          'notObject': model.notObject,
        }),
        ...(model.notString === undefined ? {} : {
          'notString': model.notString,
        }),
      };
    },
    fromJson: (json: any): TestNotRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['notObject'] === undefined ? {} : {
          notObject: json['notObject'],
        }),
        ...(json['notString'] === undefined ? {} : {
          notString: json['notString'],
        }),
      };
    },
  };

  public static TestNotRequestContentNotObjectNot = {
    toJson: (model: TestNotRequestContentNotObjectNot): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined ? {} : {
          'foo': model.foo,
        }),
      };
    },
    fromJson: (json: any): TestNotRequestContentNotObjectNot => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined ? {} : {
          foo: json['foo'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public testNot = async (input?: TestNotRequest): Promise<TestNot200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestNotRequestContent.toJson(input)) : String($IO.TestNotRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/not', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestNot200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle nullable schemas in various contexts 1`] = `
"export type PostSingleNullableObjectRequestContent = null | {
  key?: string;
};
export type TestNullable200Response = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullable200ResponseNullableObject;
};
export type TestNullable200ResponseNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContent = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentNullableObject;
  objectWithNullableProps?: TestNullableRequestContentObjectWithNullableProps;
};
export type TestNullableRequestContentNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContentObjectWithNullableProps = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentObjectWithNullablePropsNullableObject;
};
export type TestNullableRequestContentObjectWithNullablePropsNullableObject = null | {
  key?: string;
};
export type TestNullableRequestPathParameters = {
  pathParam: string | null;
};
export type TestNullableRequestQueryParameters = {
  queryString?: string | null;
  queryNumber?: number | null;
  queryInteger?: number | null;
  queryBoolean?: boolean | null;
  queryArray?: Array<string> | null;
  queryObject?: unknown | null;
};

export type PostSingleNullableArrayRequest = Array<string> | undefined;
export type PostSingleNullableArrayError = never;

export type PostSingleNullableBooleanRequest = boolean | undefined;
export type PostSingleNullableBooleanError = never;

export type PostSingleNullableNumberRequest = number | undefined;
export type PostSingleNullableNumberError = never;

export type PostSingleNullableObjectRequest = PostSingleNullableObjectRequestContent | undefined;
export type PostSingleNullableObjectError = never;

export type PostSingleNullableStringRequest = string | undefined;
export type PostSingleNullableStringError = never;

export type TestNullableRequest = TestNullableRequestPathParameters & TestNullableRequestQueryParameters & TestNullableRequestContent;
export type TestNullableError = never;
"
`;

exports[`openApiTsClientGenerator > should handle nullable schemas in various contexts 2`] = `
"import type {
  PostSingleNullableObjectRequestContent,
  TestNullable200Response,
  TestNullable200ResponseNullableObject,
  TestNullableRequestContent,
  TestNullableRequestContentNullableObject,
  TestNullableRequestContentObjectWithNullableProps,
  TestNullableRequestContentObjectWithNullablePropsNullableObject,
  TestNullableRequestPathParameters,
  TestNullableRequestQueryParameters,
  PostSingleNullableArrayRequest,
  PostSingleNullableBooleanRequest,
  PostSingleNullableNumberRequest,
  PostSingleNullableObjectRequest,
  PostSingleNullableStringRequest,
  TestNullableRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostSingleNullableObjectRequestContent = {
    toJson: (model: PostSingleNullableObjectRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined ? {} : {
          'key': model.key,
        }),
      };
    },
    fromJson: (json: any): PostSingleNullableObjectRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined ? {} : {
          key: json['key'],
        }),
      };
    },
  };

  public static TestNullable200Response = {
    toJson: (model: TestNullable200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined ? {} : {
          'nullableString': model.nullableString,
        }),
        ...(model.nullableNumber === undefined ? {} : {
          'nullableNumber': model.nullableNumber,
        }),
        ...(model.nullableInteger === undefined ? {} : {
          'nullableInteger': model.nullableInteger,
        }),
        ...(model.nullableBoolean === undefined ? {} : {
          'nullableBoolean': model.nullableBoolean,
        }),
        ...(model.nullableArray === undefined ? {} : {
          'nullableArray': model.nullableArray === null ? null : model.nullableArray,
        }),
        ...(model.nullableObject === undefined ? {} : {
          'nullableObject': $IO.TestNullable200ResponseNullableObject.toJson(model.nullableObject),
        }),
      };
    },
    fromJson: (json: any): TestNullable200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined ? {} : {
          nullableString: json['nullableString'] === null ? null : json['nullableString'],
        }),
        ...(json['nullableNumber'] === undefined ? {} : {
          nullableNumber: json['nullableNumber'] === null ? null : json['nullableNumber'],
        }),
        ...(json['nullableInteger'] === undefined ? {} : {
          nullableInteger: json['nullableInteger'] === null ? null : json['nullableInteger'],
        }),
        ...(json['nullableBoolean'] === undefined ? {} : {
          nullableBoolean: json['nullableBoolean'] === null ? null : json['nullableBoolean'],
        }),
        ...(json['nullableArray'] === undefined ? {} : {
          nullableArray: json['nullableArray'] === null ? null : json['nullableArray'],
        }),
        ...(json['nullableObject'] === undefined ? {} : {
          nullableObject: $IO.TestNullable200ResponseNullableObject.fromJson(json['nullableObject']),
        }),
      };
    },
  };

  public static TestNullable200ResponseNullableObject = {
    toJson: (model: TestNullable200ResponseNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined ? {} : {
          'key': model.key,
        }),
      };
    },
    fromJson: (json: any): TestNullable200ResponseNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined ? {} : {
          key: json['key'],
        }),
      };
    },
  };

  public static TestNullableRequestContent = {
    toJson: (model: TestNullableRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined ? {} : {
          'nullableString': model.nullableString,
        }),
        ...(model.nullableNumber === undefined ? {} : {
          'nullableNumber': model.nullableNumber,
        }),
        ...(model.nullableInteger === undefined ? {} : {
          'nullableInteger': model.nullableInteger,
        }),
        ...(model.nullableBoolean === undefined ? {} : {
          'nullableBoolean': model.nullableBoolean,
        }),
        ...(model.nullableArray === undefined ? {} : {
          'nullableArray': model.nullableArray === null ? null : model.nullableArray,
        }),
        ...(model.nullableObject === undefined ? {} : {
          'nullableObject': $IO.TestNullableRequestContentNullableObject.toJson(model.nullableObject),
        }),
        ...(model.objectWithNullableProps === undefined ? {} : {
          'objectWithNullableProps': $IO.TestNullableRequestContentObjectWithNullableProps.toJson(model.objectWithNullableProps),
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined ? {} : {
          nullableString: json['nullableString'] === null ? null : json['nullableString'],
        }),
        ...(json['nullableNumber'] === undefined ? {} : {
          nullableNumber: json['nullableNumber'] === null ? null : json['nullableNumber'],
        }),
        ...(json['nullableInteger'] === undefined ? {} : {
          nullableInteger: json['nullableInteger'] === null ? null : json['nullableInteger'],
        }),
        ...(json['nullableBoolean'] === undefined ? {} : {
          nullableBoolean: json['nullableBoolean'] === null ? null : json['nullableBoolean'],
        }),
        ...(json['nullableArray'] === undefined ? {} : {
          nullableArray: json['nullableArray'] === null ? null : json['nullableArray'],
        }),
        ...(json['nullableObject'] === undefined ? {} : {
          nullableObject: $IO.TestNullableRequestContentNullableObject.fromJson(json['nullableObject']),
        }),
        ...(json['objectWithNullableProps'] === undefined ? {} : {
          objectWithNullableProps: $IO.TestNullableRequestContentObjectWithNullableProps.fromJson(json['objectWithNullableProps']),
        }),
      };
    },
  };

  public static TestNullableRequestContentNullableObject = {
    toJson: (model: TestNullableRequestContentNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined ? {} : {
          'key': model.key,
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestContentNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined ? {} : {
          key: json['key'],
        }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullableProps = {
    toJson: (model: TestNullableRequestContentObjectWithNullableProps): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined ? {} : {
          'nullableString': model.nullableString,
        }),
        ...(model.nullableNumber === undefined ? {} : {
          'nullableNumber': model.nullableNumber,
        }),
        ...(model.nullableInteger === undefined ? {} : {
          'nullableInteger': model.nullableInteger,
        }),
        ...(model.nullableBoolean === undefined ? {} : {
          'nullableBoolean': model.nullableBoolean,
        }),
        ...(model.nullableArray === undefined ? {} : {
          'nullableArray': model.nullableArray === null ? null : model.nullableArray,
        }),
        ...(model.nullableObject === undefined ? {} : {
          'nullableObject': $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.toJson(model.nullableObject),
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestContentObjectWithNullableProps => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined ? {} : {
          nullableString: json['nullableString'] === null ? null : json['nullableString'],
        }),
        ...(json['nullableNumber'] === undefined ? {} : {
          nullableNumber: json['nullableNumber'] === null ? null : json['nullableNumber'],
        }),
        ...(json['nullableInteger'] === undefined ? {} : {
          nullableInteger: json['nullableInteger'] === null ? null : json['nullableInteger'],
        }),
        ...(json['nullableBoolean'] === undefined ? {} : {
          nullableBoolean: json['nullableBoolean'] === null ? null : json['nullableBoolean'],
        }),
        ...(json['nullableArray'] === undefined ? {} : {
          nullableArray: json['nullableArray'] === null ? null : json['nullableArray'],
        }),
        ...(json['nullableObject'] === undefined ? {} : {
          nullableObject: $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.fromJson(json['nullableObject']),
        }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullablePropsNullableObject = {
    toJson: (model: TestNullableRequestContentObjectWithNullablePropsNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined ? {} : {
          'key': model.key,
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestContentObjectWithNullablePropsNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined ? {} : {
          key: json['key'],
        }),
      };
    },
  };

  public static TestNullableRequestPathParameters = {
    toJson: (model: TestNullableRequestPathParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.pathParam === undefined ? {} : {
          'pathParam': model.pathParam,
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestPathParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        pathParam: json['pathParam'] === null ? null : json['pathParam'],
      };
    },
  };

  public static TestNullableRequestQueryParameters = {
    toJson: (model: TestNullableRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.queryString === undefined ? {} : {
          'queryString': model.queryString,
        }),
        ...(model.queryNumber === undefined ? {} : {
          'queryNumber': model.queryNumber,
        }),
        ...(model.queryInteger === undefined ? {} : {
          'queryInteger': model.queryInteger,
        }),
        ...(model.queryBoolean === undefined ? {} : {
          'queryBoolean': model.queryBoolean,
        }),
        ...(model.queryArray === undefined ? {} : {
          'queryArray': model.queryArray === null ? null : model.queryArray,
        }),
        ...(model.queryObject === undefined ? {} : {
          'queryObject': model.queryObject,
        }),
      };
    },
    fromJson: (json: any): TestNullableRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['queryString'] === undefined ? {} : {
          queryString: json['queryString'] === null ? null : json['queryString'],
        }),
        ...(json['queryNumber'] === undefined ? {} : {
          queryNumber: json['queryNumber'] === null ? null : json['queryNumber'],
        }),
        ...(json['queryInteger'] === undefined ? {} : {
          queryInteger: json['queryInteger'] === null ? null : json['queryInteger'],
        }),
        ...(json['queryBoolean'] === undefined ? {} : {
          queryBoolean: json['queryBoolean'] === null ? null : json['queryBoolean'],
        }),
        ...(json['queryArray'] === undefined ? {} : {
          queryArray: json['queryArray'] === null ? null : json['queryArray'],
        }),
        ...(json['queryObject'] === undefined ? {} : {
          queryObject: json['queryObject'] === null ? null : json['queryObject'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postSingleNullableArray = async (input?: PostSingleNullableArrayRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify(input === null ? null : input) : String(input === null ? null : input));

    const response = await this.$fetch(this.$url('/single-nullable-array', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postSingleNullableBoolean = async (input?: PostSingleNullableBooleanRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/single-nullable-boolean', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postSingleNullableNumber = async (input?: PostSingleNullableNumberRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/single-nullable-number', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postSingleNullableObject = async (input?: PostSingleNullableObjectRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostSingleNullableObjectRequestContent.toJson(input)) : String($IO.PostSingleNullableObjectRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/single-nullable-object', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postSingleNullableString = async (input?: PostSingleNullableStringRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/single-nullable-string', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public testNullable = async (input: TestNullableRequest): Promise<TestNullable200Response> => {
    const pathParameters = $IO.TestNullableRequestPathParameters.toJson(input);
    const queryParameters = $IO.TestNullableRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'queryString': 'multi',
      'queryNumber': 'multi',
      'queryInteger': 'multi',
      'queryBoolean': 'multi',
      'queryArray': 'multi',
      'queryObject': 'multi',
    } as const;
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestNullableRequestContent.toJson(input)) : String($IO.TestNullableRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test/{pathParam}', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestNullable200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle number and string constraints 1`] = `
"export type TestConstraints200Response = {
  result?: string;
};
export type TestConstraintsRequestContent = {
  constrainedInt: number;
  constrainedString: string;
  hostname?: string;
  ipv4?: string;
  ipv6?: string;
  uri?: string;
};

export type TestConstraintsRequest = TestConstraintsRequestContent | undefined;
export type TestConstraintsError = never;
"
`;

exports[`openApiTsClientGenerator > should handle number and string constraints 2`] = `
"import type {
  TestConstraints200Response,
  TestConstraintsRequestContent,
  TestConstraintsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestConstraints200Response = {
    toJson: (model: TestConstraints200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined ? {} : {
          'result': model.result,
        }),
      };
    },
    fromJson: (json: any): TestConstraints200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined ? {} : {
          result: json['result'],
        }),
      };
    },
  };

  public static TestConstraintsRequestContent = {
    toJson: (model: TestConstraintsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.constrainedInt === undefined ? {} : {
          'constrainedInt': model.constrainedInt,
        }),
        ...(model.constrainedString === undefined ? {} : {
          'constrainedString': model.constrainedString,
        }),
        ...(model.hostname === undefined ? {} : {
          'hostname': model.hostname,
        }),
        ...(model.ipv4 === undefined ? {} : {
          'ipv4': model.ipv4,
        }),
        ...(model.ipv6 === undefined ? {} : {
          'ipv6': model.ipv6,
        }),
        ...(model.uri === undefined ? {} : {
          'uri': model.uri,
        }),
      };
    },
    fromJson: (json: any): TestConstraintsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        constrainedInt: json['constrainedInt'],
        constrainedString: json['constrainedString'],
        ...(json['hostname'] === undefined ? {} : {
          hostname: json['hostname'],
        }),
        ...(json['ipv4'] === undefined ? {} : {
          ipv4: json['ipv4'],
        }),
        ...(json['ipv6'] === undefined ? {} : {
          ipv6: json['ipv6'],
        }),
        ...(json['uri'] === undefined ? {} : {
          uri: json['uri'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public testConstraints = async (input?: TestConstraintsRequest): Promise<TestConstraints200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TestConstraintsRequestContent.toJson(input)) : String($IO.TestConstraintsRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/constraints', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.TestConstraints200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle only default response 1`] = `
"export type GetTestdefaultResponse = {
  message: string;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle only default response 2`] = `
"import type {
  GetTestdefaultResponse,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTestdefaultResponse = {
    toJson: (model: GetTestdefaultResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined ? {} : {
          'message': model.message,
        }),
      };
    },
    fromJson: (json: any): GetTestdefaultResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public getTest = async (): Promise<GetTestdefaultResponse> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    return $IO.GetTestdefaultResponse.fromJson(await response.json());
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operation tags and multiple services 1`] = `
"export type CreateUserError = never;
export type GetItemsError = never;
export type GetStatusError = never;
export type GetUsersError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operation tags and multiple services 2`] = `
"
/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  private _createUser = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/users', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 201) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  /**
   * Returns a list of all the items
   */
  private _getItems = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/items', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public getStatus = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/status', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  private _getUsers = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/users', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  /**
   * users operations
   */
  public users = {
    createUser: this._createUser,
    getUsers: this._getUsers,
  };

  /**
   * items operations
   */
  public items = {
    /**
     * Returns a list of all the items
     */
    getItems: this._getItems,
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with complex map types 1`] = `
"export type PostMapOfArraysOfObjectsRequestContent = {
  [key: string]: Array<PostMapOfArraysOfObjectsRequestContentValueItem>;
};
export type PostMapOfArraysOfObjectsRequestContentValueItem = {
  name: string;
  value: number;
};
export type PostMapOfMapsOfArraysOfNumbersRequestContent = {
  [key: string]: { [key: string]: Array<number>; };
};
export type PostMapOfMapsOfNumbersRequestContent = {
  [key: string]: { [key: string]: number; };
};
export type PostMapOfNumbersRequestContent = {
  [key: string]: number;
};
export type PostMapOfObjectsRequestContent = {
  [key: string]: PostMapOfObjectsRequestContentValue;
};
export type PostMapOfObjectsRequestContentValue = {
  name: string;
  value: number;
};

export type PostArrayOfMapsOfArraysOfNumbersRequest = Array<{ [key: string]: Array<number>; }> | undefined;
export type PostArrayOfMapsOfArraysOfNumbersError = never;

export type PostArrayOfMapsOfNumbersRequest = Array<{ [key: string]: number; }> | undefined;
export type PostArrayOfMapsOfNumbersError = never;

export type PostMapOfArraysOfObjectsRequest = PostMapOfArraysOfObjectsRequestContent | undefined;
export type PostMapOfArraysOfObjectsError = never;

export type PostMapOfMapsOfArraysOfNumbersRequest = PostMapOfMapsOfArraysOfNumbersRequestContent | undefined;
export type PostMapOfMapsOfArraysOfNumbersError = never;

export type PostMapOfMapsOfNumbersRequest = PostMapOfMapsOfNumbersRequestContent | undefined;
export type PostMapOfMapsOfNumbersError = never;

export type PostMapOfNumbersRequest = PostMapOfNumbersRequestContent | undefined;
export type PostMapOfNumbersError = never;

export type PostMapOfObjectsRequest = PostMapOfObjectsRequestContent | undefined;
export type PostMapOfObjectsError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with complex map types 2`] = `
"import type {
  PostMapOfArraysOfObjectsRequestContent,
  PostMapOfArraysOfObjectsRequestContentValueItem,
  PostMapOfMapsOfArraysOfNumbersRequestContent,
  PostMapOfMapsOfNumbersRequestContent,
  PostMapOfNumbersRequestContent,
  PostMapOfObjectsRequestContent,
  PostMapOfObjectsRequestContentValue,
  PostArrayOfMapsOfArraysOfNumbersRequest,
  PostArrayOfMapsOfNumbersRequest,
  PostMapOfArraysOfObjectsRequest,
  PostMapOfMapsOfArraysOfNumbersRequest,
  PostMapOfMapsOfNumbersRequest,
  PostMapOfNumbersRequest,
  PostMapOfObjectsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostMapOfArraysOfObjectsRequestContent = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...($IO.mapValues(model, (item0) => item0.map($IO.PostMapOfArraysOfObjectsRequestContentValueItem.toJson))),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...($IO.mapValues(json, (item0) => item0.map($IO.PostMapOfArraysOfObjectsRequestContentValueItem.fromJson))),
      };
    },
  };

  public static PostMapOfArraysOfObjectsRequestContentValueItem = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContentValueItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined ? {} : {
          'name': model.name,
        }),
        ...(model.value === undefined ? {} : {
          'value': model.value,
        }),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContentValueItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };

  public static PostMapOfMapsOfArraysOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfArraysOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfArraysOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfMapsOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfNumbersRequestContent = {
    toJson: (model: PostMapOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfObjectsRequestContent = {
    toJson: (model: PostMapOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...($IO.mapValues(model, $IO.PostMapOfObjectsRequestContentValue.toJson)),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...($IO.mapValues(json, $IO.PostMapOfObjectsRequestContentValue.fromJson)),
      };
    },
  };

  public static PostMapOfObjectsRequestContentValue = {
    toJson: (model: PostMapOfObjectsRequestContentValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined ? {} : {
          'name': model.name,
        }),
        ...(model.value === undefined ? {} : {
          'value': model.value,
        }),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContentValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postArrayOfMapsOfArraysOfNumbers = async (input?: PostArrayOfMapsOfArraysOfNumbersRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify(input) : String(input));

    const response = await this.$fetch(this.$url('/array-of-maps-of-arrays-of-numbers', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postArrayOfMapsOfNumbers = async (input?: PostArrayOfMapsOfNumbersRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify(input) : String(input));

    const response = await this.$fetch(this.$url('/array-of-maps-of-numbers', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postMapOfArraysOfObjects = async (input?: PostMapOfArraysOfObjectsRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostMapOfArraysOfObjectsRequestContent.toJson(input)) : String($IO.PostMapOfArraysOfObjectsRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/map-of-arrays-of-objects', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postMapOfMapsOfArraysOfNumbers = async (input?: PostMapOfMapsOfArraysOfNumbersRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input)) : String($IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/map-of-maps-of-arrays-of-numbers', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postMapOfMapsOfNumbers = async (input?: PostMapOfMapsOfNumbersRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostMapOfMapsOfNumbersRequestContent.toJson(input)) : String($IO.PostMapOfMapsOfNumbersRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/map-of-maps-of-numbers', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postMapOfNumbers = async (input?: PostMapOfNumbersRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostMapOfNumbersRequestContent.toJson(input)) : String($IO.PostMapOfNumbersRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/map-of-numbers', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postMapOfObjects = async (input?: PostMapOfObjectsRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostMapOfObjectsRequestContent.toJson(input)) : String($IO.PostMapOfObjectsRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/map-of-objects', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with multiple tags 1`] = `
"export type GetMultiTaggedError = never;
export type PostMultiTaggedError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with multiple tags 2`] = `
"
/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  private _getMultiTagged = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/multi-tagged', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  private _postMultiTagged = async (): Promise<number> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/multi-tagged', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return Number(await response.text());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  /**
   * tag1 operations
   */
  public tag1 = {
    getMultiTagged: this._getMultiTagged,
    postMultiTagged: this._postMultiTagged,
  };

  /**
   * tag2 operations
   */
  public tag2 = {
    getMultiTagged: this._getMultiTagged,
  };

  /**
   * tag3 operations
   */
  public tag3 = {
    getMultiTagged: this._getMultiTagged,
    postMultiTagged: this._postMultiTagged,
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with simple request bodies and query parameters 1`] = `
"export type PostBooleanWithQueryRequestBodyParameters = {
  body?: boolean;
};
export type PostBooleanWithQueryRequestQueryParameters = {
  filter?: string;
};
export type PostNumberWithQueryRequestBodyParameters = {
  body?: number;
};
export type PostNumberWithQueryRequestQueryParameters = {
  filter?: string;
};
export type PostStringWithQueryRequestBodyParameters = {
  body?: string;
};
export type PostStringWithQueryRequestQueryParameters = {
  filter?: string;
};

export type PostBooleanRequest = boolean | undefined;
export type PostBooleanError = never;

export type PostBooleanWithQueryRequest = PostBooleanWithQueryRequestQueryParameters & PostBooleanWithQueryRequestBodyParameters;
export type PostBooleanWithQueryError = never;

export type PostNumberRequest = number | undefined;
export type PostNumberError = never;

export type PostNumberWithQueryRequest = PostNumberWithQueryRequestQueryParameters & PostNumberWithQueryRequestBodyParameters;
export type PostNumberWithQueryError = never;

export type PostStringRequest = string | undefined;
export type PostStringError = never;

export type PostStringWithQueryRequest = PostStringWithQueryRequestQueryParameters & PostStringWithQueryRequestBodyParameters;
export type PostStringWithQueryError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with simple request bodies and query parameters 2`] = `
"import type {
  PostBooleanWithQueryRequestBodyParameters,
  PostBooleanWithQueryRequestQueryParameters,
  PostNumberWithQueryRequestBodyParameters,
  PostNumberWithQueryRequestQueryParameters,
  PostStringWithQueryRequestBodyParameters,
  PostStringWithQueryRequestQueryParameters,
  PostBooleanRequest,
  PostBooleanWithQueryRequest,
  PostNumberRequest,
  PostNumberWithQueryRequest,
  PostStringRequest,
  PostStringWithQueryRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostBooleanWithQueryRequestBodyParameters = {
    toJson: (model: PostBooleanWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined ? {} : {
          'body': model.body,
        }),
      };
    },
    fromJson: (json: any): PostBooleanWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined ? {} : {
          body: json['body'],
        }),
      };
    },
  };

  public static PostBooleanWithQueryRequestQueryParameters = {
    toJson: (model: PostBooleanWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': model.filter,
        }),
      };
    },
    fromJson: (json: any): PostBooleanWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined ? {} : {
          filter: json['filter'],
        }),
      };
    },
  };

  public static PostNumberWithQueryRequestBodyParameters = {
    toJson: (model: PostNumberWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined ? {} : {
          'body': model.body,
        }),
      };
    },
    fromJson: (json: any): PostNumberWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined ? {} : {
          body: json['body'],
        }),
      };
    },
  };

  public static PostNumberWithQueryRequestQueryParameters = {
    toJson: (model: PostNumberWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': model.filter,
        }),
      };
    },
    fromJson: (json: any): PostNumberWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined ? {} : {
          filter: json['filter'],
        }),
      };
    },
  };

  public static PostStringWithQueryRequestBodyParameters = {
    toJson: (model: PostStringWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined ? {} : {
          'body': model.body,
        }),
      };
    },
    fromJson: (json: any): PostStringWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined ? {} : {
          body: json['body'],
        }),
      };
    },
  };

  public static PostStringWithQueryRequestQueryParameters = {
    toJson: (model: PostStringWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': model.filter,
        }),
      };
    },
    fromJson: (json: any): PostStringWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined ? {} : {
          filter: json['filter'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postBoolean = async (input?: PostBooleanRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/boolean', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postBooleanWithQuery = async (input: PostBooleanWithQueryRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = $IO.PostBooleanWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'filter': 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(this.$url('/boolean-with-query', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postNumber = async (input?: PostNumberRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/number', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postNumberWithQuery = async (input: PostNumberWithQueryRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = $IO.PostNumberWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'filter': 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(this.$url('/number-with-query', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postString = async (input?: PostStringRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(this.$url('/string', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public postStringWithQuery = async (input: PostStringWithQueryRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = $IO.PostStringWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'filter': 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(this.$url('/string-with-query', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle recursive schema references 1`] = `
"export type TreeNode = {
  id: string;
  name: string;
  children?: Array<TreeNode>;
};

export type CreateTreeRequest = TreeNode | undefined;
export type CreateTreeError = never;
export type GetTreeError = never;
"
`;

exports[`openApiTsClientGenerator > should handle recursive schema references 2`] = `
"import type {
  TreeNode,
  CreateTreeRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TreeNode = {
    toJson: (model: TreeNode): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined ? {} : {
          'id': model.id,
        }),
        ...(model.name === undefined ? {} : {
          'name': model.name,
        }),
        ...(model.children === undefined ? {} : {
          'children': (model.children.map($IO.TreeNode.toJson)),
        }),
      };
    },
    fromJson: (json: any): TreeNode => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        ...(json['children'] === undefined ? {} : {
          children: ((json['children'] as Array<any>).map($IO.TreeNode.fromJson)),
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public createTree = async (input?: CreateTreeRequest): Promise<TreeNode> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.TreeNode.toJson(input)) : String($IO.TreeNode.toJson(input)));

    const response = await this.$fetch(this.$url('/tree', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 201) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };

  public getTree = async (): Promise<TreeNode> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(this.$url('/tree', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'GET',
      body,
    });

    if (response.status === 200) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle refs and hoisting of inline schemas 1`] = `
"export type Error = {
  code: string;
  message: string;
};
export type PostTestRequestContent = {
  inline?: PostTestRequestContentInline;
  referenced?: Error;
};
export type PostTestRequestContentInline = {
  name?: string;
  details?: PostTestRequestContentInlineDetails;
};
export type PostTestRequestContentInlineDetails = {
  age?: number;
  active?: boolean;
};

export type PostTestRequest = PostTestRequestContent;
export type PostTest400Error = {
  status: 400;
  error: Error;
};
export type PostTestError = PostTest400Error;
"
`;

exports[`openApiTsClientGenerator > should handle refs and hoisting of inline schemas 2`] = `
"import type {
  Error,
  PostTestRequestContent,
  PostTestRequestContentInline,
  PostTestRequestContentInlineDetails,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static Error = {
    toJson: (model: Error): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.code === undefined ? {} : {
          'code': model.code,
        }),
        ...(model.message === undefined ? {} : {
          'message': model.message,
        }),
      };
    },
    fromJson: (json: any): Error => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        code: json['code'],
        message: json['message'],
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.inline === undefined ? {} : {
          'inline': $IO.PostTestRequestContentInline.toJson(model.inline),
        }),
        ...(model.referenced === undefined ? {} : {
          'referenced': $IO.Error.toJson(model.referenced),
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['inline'] === undefined ? {} : {
          inline: $IO.PostTestRequestContentInline.fromJson(json['inline']),
        }),
        ...(json['referenced'] === undefined ? {} : {
          referenced: $IO.Error.fromJson(json['referenced']),
        }),
      };
    },
  };

  public static PostTestRequestContentInline = {
    toJson: (model: PostTestRequestContentInline): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined ? {} : {
          'name': model.name,
        }),
        ...(model.details === undefined ? {} : {
          'details': $IO.PostTestRequestContentInlineDetails.toJson(model.details),
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInline => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['name'] === undefined ? {} : {
          name: json['name'],
        }),
        ...(json['details'] === undefined ? {} : {
          details: $IO.PostTestRequestContentInlineDetails.fromJson(json['details']),
        }),
      };
    },
  };

  public static PostTestRequestContentInlineDetails = {
    toJson: (model: PostTestRequestContentInlineDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.age === undefined ? {} : {
          'age': model.age,
        }),
        ...(model.active === undefined ? {} : {
          'active': model.active,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInlineDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['age'] === undefined ? {} : {
          age: json['age'],
        }),
        ...(json['active'] === undefined ? {} : {
          active: json['active'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postTest = async (input: PostTestRequest): Promise<void> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = (typeof input === 'object' ? JSON.stringify($IO.PostTestRequestContent.toJson(input)) : String($IO.PostTestRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters), {
      headers: this.$headers(headerParameters),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return undefined;
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.Error.fromJson(await response.json()),
      };
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle request body property matching query parameter name 1`] = `
"export type PostTest200Response = {
  result?: string;
};
export type PostTestRequestBodyParameters = {
  body?: PostTestRequestContent;
};
export type PostTestRequestContent = {
  filter: PostTestRequestContentFilter;
  data: string;
};
export type PostTestRequestContentFilter = {
  value?: string;
};
export type PostTestRequestQueryParameters = {
  filter?: string;
};

export type PostTestRequest = PostTestRequestQueryParameters & PostTestRequestBodyParameters;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle request body property matching query parameter name 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestBodyParameters,
  PostTestRequestContent,
  PostTestRequestContentFilter,
  PostTestRequestQueryParameters,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined ? {} : {
          'result': model.result,
        }),
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined ? {} : {
          result: json['result'],
        }),
      };
    },
  };

  public static PostTestRequestBodyParameters = {
    toJson: (model: PostTestRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined ? {} : {
          'body': $IO.PostTestRequestContent.toJson(model.body),
        }),
      };
    },
    fromJson: (json: any): PostTestRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined ? {} : {
          body: $IO.PostTestRequestContent.fromJson(json['body']),
        }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': $IO.PostTestRequestContentFilter.toJson(model.filter),
        }),
        ...(model.data === undefined ? {} : {
          'data': model.data,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        filter: $IO.PostTestRequestContentFilter.fromJson(json['filter']),
        data: json['data'],
      };
    },
  };

  public static PostTestRequestContentFilter = {
    toJson: (model: PostTestRequestContentFilter): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.value === undefined ? {} : {
          'value': model.value,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContentFilter => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['value'] === undefined ? {} : {
          value: json['value'],
        }),
      };
    },
  };

  public static PostTestRequestQueryParameters = {
    toJson: (model: PostTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined ? {} : {
          'filter': model.filter,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined ? {} : {
          filter: json['filter'],
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postTest = async (input: PostTestRequest): Promise<PostTest200Response> => {
    const pathParameters = {};
    const queryParameters = $IO.PostTestRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'filter': 'multi',
    } as const;
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostTestRequestBodyParameters.toJson(input).body) : String($IO.PostTestRequestBodyParameters.toJson(input).body));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle special formats and vendor extensions 1`] = `
"export type PostTest200Response = {
  createdAt?: Date;
};
export type PostTestRequestContent = {
  int32?: number;
  int64?: number;
  float?: number;
  double?: number;
  binary?: Blob;
  byte?: string;
  uuid?: string;
  email?: string;
};
export type PostTestRequestQueryParameters = {
  date?: Date;
  timestamp?: Date;
};

export type PostTestRequest = PostTestRequestQueryParameters & PostTestRequestContent;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle special formats and vendor extensions 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestContent,
  PostTestRequestQueryParameters,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.createdAt === undefined ? {} : {
          'createdAt': (model.createdAt.toISOString()),
        }),
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['createdAt'] === undefined ? {} : {
          createdAt: (new Date(json['createdAt'])),
        }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.int32 === undefined ? {} : {
          'int32': model.int32,
        }),
        ...(model.int64 === undefined ? {} : {
          'int64': model.int64,
        }),
        ...(model.float === undefined ? {} : {
          'float': model.float,
        }),
        ...(model.double === undefined ? {} : {
          'double': model.double,
        }),
        ...(model.binary === undefined ? {} : {
          'binary': model.binary,
        }),
        ...(model.byte === undefined ? {} : {
          'byte': model.byte,
        }),
        ...(model.uuid === undefined ? {} : {
          'uuid': model.uuid,
        }),
        ...(model.email === undefined ? {} : {
          'email': model.email,
        }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['int32'] === undefined ? {} : {
          int32: json['int32'],
        }),
        ...(json['int64'] === undefined ? {} : {
          int64: json['int64'],
        }),
        ...(json['float'] === undefined ? {} : {
          float: json['float'],
        }),
        ...(json['double'] === undefined ? {} : {
          double: json['double'],
        }),
        ...(json['binary'] === undefined ? {} : {
          binary: json['binary'],
        }),
        ...(json['byte'] === undefined ? {} : {
          byte: json['byte'],
        }),
        ...(json['uuid'] === undefined ? {} : {
          uuid: json['uuid'],
        }),
        ...(json['email'] === undefined ? {} : {
          email: json['email'],
        }),
      };
    },
  };

  public static PostTestRequestQueryParameters = {
    toJson: (model: PostTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.date === undefined ? {} : {
          'date': (model.date.toISOString().slice(0,10)),
        }),
        ...(model.timestamp === undefined ? {} : {
          'timestamp': (model.timestamp.toISOString()),
        }),
      };
    },
    fromJson: (json: any): PostTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['date'] === undefined ? {} : {
          date: (new Date(json['date'])),
        }),
        ...(json['timestamp'] === undefined ? {} : {
          timestamp: (new Date(json['timestamp'])),
        }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (path: string, pathParameters: { [key: string]: any }, queryParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): string => {
    const baseUrl = this.$config.url.endsWith('/') ? this.$config.url.slice(0, -1) : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce((withParams, [key, value]) =>
      withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`))
    , path);
    const queryString = Object.entries(queryParameters).map(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`).join('&');
      }
      return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
    }).join('&');
    return baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '');
  };

  private $headers = (headerParameters: { [key: string]: any }, collectionFormats?: { [key: string]: 'multi' | 'csv' }): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map(v => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) => (this.$config.fetch ?? fetch)(...args);

  public postTest = async (input: PostTestRequest): Promise<PostTest200Response> => {
    const pathParameters = {};
    const queryParameters = $IO.PostTestRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      'date': 'multi',
      'timestamp': 'multi',
    } as const;
    const body = input === undefined ? undefined : (typeof input === 'object' ? JSON.stringify($IO.PostTestRequestContent.toJson(input)) : String($IO.PostTestRequestContent.toJson(input)));

    const response = await this.$fetch(this.$url('/test', pathParameters, queryParameters, collectionFormats), {
      headers: this.$headers(headerParameters, collectionFormats),
      method: 'POST',
      body,
    });

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(\`Unknown response status \${response.status} returned by API\`);
  };
}
"
`;
