/*! Copyright [Amazon.com](http://amazon.com/), Inc. or its affiliates. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0 */
import * as url from 'url';
import { PDKNag } from '@aws/pdk/pdk-nag';
import { CfnOutput, RemovalPolicy, Stack } from 'aws-cdk-lib';
import { Distribution, ViewerProtocolPolicy } from 'aws-cdk-lib/aws-cloudfront';
import { S3BucketOrigin } from 'aws-cdk-lib/aws-cloudfront-origins';
import {
  BlockPublicAccess,
  Bucket,
  BucketEncryption,
  IBucket,
  ObjectOwnership,
} from 'aws-cdk-lib/aws-s3';
import { BucketDeployment, Source } from 'aws-cdk-lib/aws-s3-deployment';
import { NagSuppressions } from 'cdk-nag';
import { Construct } from 'constructs';
import { CloudfrontWebAcl } from './cloudfront-web-acl.js';
import { RuntimeConfig } from '../runtime-config/index.js';

const DEFAULT_RUNTIME_CONFIG_FILENAME = 'runtime-config.json';

/**
 * Deploys a Static Website using by default a private S3 bucket as an origin and Cloudfront as the entrypoint.
 *
 * This construct configures a webAcl containing rules that are generally applicable to web applications. This
 * provides protection against exploitation of a wide range of vulnerabilities, including some of the high risk
 * and commonly occurring vulnerabilities described in OWASP publications such as OWASP Top 10.
 *
 */
export class StaticWebsite extends Construct {
  public readonly websiteBucket: IBucket;
  public readonly cloudFrontDistribution: Distribution;
  public readonly bucketDeployment: BucketDeployment;

  constructor(scope: Construct, id: string) {
    super(scope, id);

    this.node.setContext(
      '@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy',
      true
    );

    const accessLogsBucket = new Bucket(this, 'AccessLogsBucket', {
      versioned: false,
      enforceSSL: true,
      autoDeleteObjects: true,
      removalPolicy: RemovalPolicy.DESTROY,
      encryption: BucketEncryption.S3_MANAGED,
      objectOwnership: ObjectOwnership.OBJECT_WRITER,
      publicReadAccess: false,
      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
    });

    // S3 Bucket to hold website files
    this.websiteBucket = new Bucket(this, 'WebsiteBucket', {
      versioned: true,
      enforceSSL: true,
      autoDeleteObjects: true,
      removalPolicy: RemovalPolicy.DESTROY,
      encryption: BucketEncryption.S3_MANAGED,
      objectOwnership: ObjectOwnership.BUCKET_OWNER_ENFORCED,
      publicReadAccess: false,
      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
      serverAccessLogsPrefix: 'website-access-logs',
      serverAccessLogsBucket: accessLogsBucket,
    });

    // Web ACL
    const webAclArn = new CloudfrontWebAcl(this, 'WebsiteAcl').webAclArn;

    // Cloudfront Distribution
    const logBucket = new Bucket(this, 'DistributionLogBucket', {
      enforceSSL: true,
      autoDeleteObjects: true,
      removalPolicy: RemovalPolicy.DESTROY,
      encryption: BucketEncryption.S3_MANAGED,
      objectOwnership: ObjectOwnership.BUCKET_OWNER_PREFERRED,
      publicReadAccess: false,
      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
      serverAccessLogsPrefix: 'distribution-access-logs',
      serverAccessLogsBucket: accessLogsBucket,
    });

    const defaultRootObject = 'index.html';
    this.cloudFrontDistribution = new Distribution(
      this,
      'CloudfrontDistribution',
      {
        webAclId: webAclArn,
        enableLogging: true,
        logBucket: logBucket,
        defaultBehavior: {
          origin: S3BucketOrigin.withOriginAccessControl(this.websiteBucket),
          viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
        },
        defaultRootObject,
        errorResponses: [
          {
            httpStatus: 404, // We need to redirect "key not found errors" to index.html for single page apps
            responseHttpStatus: 200,
            responsePagePath: `/${defaultRootObject}`,
          },
        ],
      }
    );

    // Deploy Website
    const runtimeConfig = RuntimeConfig.ensure(this).config;
    this.bucketDeployment = new BucketDeployment(this, 'WebsiteDeployment', {
      sources: [
        Source.asset(url.fileURLToPath(new URL('../../../../../<%= websiteContentPath %>', import.meta.url))),
        ...(Object.keys(runtimeConfig).length > 0
          ? [
              Source.jsonData(DEFAULT_RUNTIME_CONFIG_FILENAME, runtimeConfig),
            ]
          : []),
      ],
      destinationBucket: this.websiteBucket,
      // Files in the distribution's edge caches will be invalidated after files are uploaded to the destination bucket.
      distribution: this.cloudFrontDistribution,
    });

    new CfnOutput(this, 'DistributionDomainName', {
      value: this.cloudFrontDistribution.domainName,
    });

    this.suppressCDKNagViolations();
  }

  private suppressCDKNagViolations = () => {
    const stack = Stack.of(this);

    NagSuppressions.addResourceSuppressions(
      this,
      [
        {
          id: 'AwsPrototyping-CloudFrontDistributionGeoRestrictions',
          reason:
            'Suppressed to allow unrestricted access. Not recommended in production.',
        },
      ],
      true
    );

    [
      'AwsSolutions-CFR4',
      'AwsPrototyping-CloudFrontDistributionHttpsViewerNoOutdatedSSL',
    ].forEach((RuleId) => {
      NagSuppressions.addResourceSuppressions(this.cloudFrontDistribution, [
        {
          id: RuleId,
          reason:
            'Certificate is not mandatory therefore the Cloudfront certificate will be used.',
        },
      ]);
    });

    ['AwsSolutions-L1', 'AwsPrototyping-LambdaLatestVersion'].forEach(
      (RuleId) => {
        NagSuppressions.addResourceSuppressions(
          this,
          [
            {
              id: RuleId,
              reason:
                'Latest runtime cannot be configured. CDK will need to upgrade the BucketDeployment construct accordingly.',
            },
          ],
          true
        );
      }
    );

    ['AwsSolutions-IAM5', 'AwsPrototyping-IAMNoWildcardPermissions'].forEach(
      (RuleId) => {
        NagSuppressions.addResourceSuppressions(
          this,
          [
            {
              id: RuleId,
              reason:
                'All Policies have been scoped to a Bucket. Given Buckets can contain arbitrary content, wildcard resources with bucket scope are required.',
              appliesTo: [
                {
                  regex: '/^Action::s3:.*$/g',
                },
                {
                  regex: `/^Resource::.*$/g`,
                },
              ],
            },
          ],
          true
        );
      }
    );

    ['AwsSolutions-IAM4', 'AwsPrototyping-IAMNoManagedPolicies'].forEach(
      (RuleId) => {
        NagSuppressions.addResourceSuppressions(
          this,
          [
            {
              id: RuleId,
              reason:
                'Buckets can contain arbitrary content, therefore wildcard resources under a bucket are required.',
              appliesTo: [
                {
                  regex: `/^Policy::arn:${PDKNag.getStackPartitionRegex(
                    stack
                  )}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole$/g`,
                },
              ],
            },
          ],
          true
        );
      }
    );

    ['AwsSolutions-S1', 'AwsPrototyping-S3BucketLoggingEnabled'].forEach(
      (RuleId) => {
        NagSuppressions.addResourceSuppressions(
          this,
          [
            {
              id: RuleId,
              reason: 'Access Log buckets should not have s3 bucket logging',
            },
          ],
          true
        );
      }
    );
  };
}
