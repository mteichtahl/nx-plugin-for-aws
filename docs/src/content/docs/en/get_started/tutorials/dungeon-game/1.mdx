---
title: AI Dungeon Game
description: A walkthrough of how to build an AI powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 1: Monorepo setup

We are going to start by creating a new monorepo. From within your desired directory, run the following command:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

This will set up a NX monorepo within the `dungeon-adventure` directory which you can then open in vscode. It should look like the following:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ this is where your sub-projects will reside
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configures the Nx CLI and monorepo defaults
- package.json all node dependencies are defined here
- pnpm-lock.yaml or bun.lock, yarn.lock, package-lock.json depending on package manager
- pnpm-workspace.yaml if using pnpm
- README.md
- tsconfig.base.json all node based sub-projects extend this
- tsconfig.json
</FileTree>

Now we are ready to start creating our different sub-projects using the `@aws/nx-plugin`.

<Aside type="tip">It is a best practice to ensure all your unstaged files are commited in Git before running any generators. This allows you to see what has changed after running your generator via `git diff`</Aside>

### Game API

First let's create our Game API. To do this, let's create a tRPC API called `GameApi` by following the below steps:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

You should see some new files have appeared in your file tree.

<Aside>
The root `package.json` is now configured with a `type` of `module` which means ESM is the default module type for all node based sub-projects vended by the `@aws/nx-plugin`. For more details on working with TypeScript projects, refer to the <Link path="guides/typescript-project">ts#project guide</Link>.
</Aside>

<Drawer title="ts#trpc-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#trpc-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - apis/
            - **game-api.ts** cdk construct to create your tRPC API
            - index.ts
            - ...
          - index.ts
        - core/ generic cdk constructs
          - api/
            - rest-api.ts base cdk construct for an API Gateway Rest API
            - trpc-utils.ts utilities for trpc API CDK constructs
            - utils.ts utilities for API constructs
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ shared types
      - src/
        - index.ts
        - runtime-config.ts interface definition used by both CDK and website
      - project.json
      - ...
  - game-api/ tRPC API
    - src/
      - client/ vanilla client typically used for ts machine to machine calls
        - index.ts
        - sigv4.ts
      - middleware/ powertools instrumentation
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definitions of inputs and outputs for your API
        - **echo.ts**
      - procedures/ specific implementations for your API procedures/routes
        - **echo.ts**
      - index.ts
      - init.ts sets up context and middleware
      - local-server.ts used when running the tRPC server locally
      - **router.ts** entrypoint for your lambda handler which defines all procedures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Taking a look at a few of the key files:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
The router defines the entrypoint for your tRPC API and is the place where you will declare all of your API methods. As you can see above, we have a method called `echo` with it's implementation living in the `./procedures/echo.ts` file.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

This file is the implementation of the `echo` method and as you can see is strongly typed by declaring its input and output data structures.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

All tRPC schema definitions are defined using [Zod](https://zod.dev/) and are exported as typescript types via the `z.TypeOf` syntax.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// String union type for all API operation names
type Operations = Procedures<AppRouter>;

/**
 * Properties for creating a GameApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for GameApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Here we grant any AWS credentials from the account that the project is deployed in to call the api.
          // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
          // users) and resources (eg which api paths may be invoked by which principal) if required.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

This is the CDK construct that defines our GameApi. As you can see, it provides a `defaultIntegrations` method which automatically creates a lambda function for each procedure in our tRPC API, pointing to the bundled API implementation. This means that at `cdk synth` time, bundling does not occur (opposed to using [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) as we have already bundled it as part of the backend project's build target.

</Drawer>

### Story API

Now let's create our Story API. To do this, let's create a Fast API called `StoryApi` by following the below steps:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

You should see some new files have appeared in your file tree.
<Drawer title="py#fast-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `py#fast-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- .venv/ single virtual env for monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - apis/
            - **story-api.ts** cdk construct to create your Fast API
            - index.ts updated to export the new story-api
      - project.json updated to add a build dep on story_api
    - types/ shared types
      - src/
        - **runtime-config.ts** updated to add the StoryApi
  - story_api/
    - story_api/ python module
      - init.py sets up powertools, FastAPI and middleware
      - **main.py** entrypoint for the lambda containing all routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version pinned uv python version
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Properties for creating a StoryApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for StoryApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Here we grant any AWS credentials from the account that the project is deployed in to call the api.
          // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
          // users) and resources (eg which api paths may be invoked by which principal) if required.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

This is the CDK construct that defines our StoryApi. As you can see, it provides a `defaultIntegrations` method which automatically creates a lambda function for each operation defined in our FastAPI, pointing to the bundled API implementation. This means that at `cdk synth` time, bundling does not occur (opposed to [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) as we have already bundled it as part of the backend project's build target.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Here is an example of the generator performing an AST transform which preserves all existing code and performs an update. Here you can see the `StoryApi` was added to the `IRuntimeConfig` definition which means when this is eventually consumed by our frontend, it will enforce type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

This is where all your API method will be defined. As you can see here, we have a `read_root` method mapped to the `GET /` route. You can use [Pydantic](https://docs.pydantic.dev/latest/) to declare your method inputs and outputs to ensure type safety.

</Drawer>

### Game UI: Website

Now let's create the UI which will enable you to interact with the game. To do this, let's create a website called `GameUI` by following the below steps:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

You should see some new files have appeared in your file tree.

<Drawer title="ts#cloudscape-website updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#cloudscape-website` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - static-websites/
            - **game-ui.ts** cdk construct to create your Game UI
        - core/
          - static-website.ts generic static website construct
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts overall page layout: header, footer, sidebar, etc
          - navitems.ts sidebar nav items
      - hooks/
        - useAppLayout.tsx allows you to dynamically set things like notifications, page style, etc
      - routes/ @tanstack/react-router file based routes
        - index.tsx root '/' page redirects to '/welcome'
        - __root.tsx all pages use this component as a base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** React entrypoint
        - routeTree.gen.ts this is automatically updated by @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameUI. As you can see, it has already configured the file path to the generated bundle for our Vite based UI. This means that at `build` time, bundling occurs within the game-ui project's build target and it's output is used here.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

This is the entrypoint where React is mounted. As shown, it initially just configures a `@tanstack/react-router` in a [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing) configuration. This means, as long as your development server is running - you can simply create files within the `routes` folder and `@tanstack/react-router` will create the boilerplate file setup for you along with updating the `routeTree.gen.ts` file. This file maintains all routes in a type-safe manner, which means when you use `<Link>`- the `to` option will only show valid routes. For more information, refer to the [`@tanstack/react-router` docs](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

A component which will be rendered when navigating to the `/welcome` route. `@tanstack/react-router` will manage the `Route` for you whenever you create/move this file (as long as the dev server is running). This will be shown in a later section of this tutorial.

</Drawer>

### Game UI: Auth

Now let's configure our Game UI to require authenticated access via Amazon Cognito by following the below steps:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#cloudscape-website#auth updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#cloudscape-website#auth` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts cdk construct for creating user/identity pools
    - types/
      - src/
        - runtime-config.ts updated to add the cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adds the logged in user/logout to the header
        - CognitoAuth/
          - index.ts manages logging into Cognito
        - RuntimeConfig/
          - index.tsx fetches the `runtime-config.json` and provides it to children via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Updated to add Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `RuntimeConfigProvider` and `CognitoAuth` components have been added to the `main.tsx` file via an AST transform. This allows the `CognitoAuth` component to authenticate with Amazon Cognito by fetching the `runtime-config.json` which contains the required cognito connection configuration in order to make the backend calls to the correct destination.

</Drawer>

### Game UI: Connect to Story API

Now let's configure our Game UI to connect to our previously created Story API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> FastAPI api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx used by StoryApi to sign requests
        - useStoryApiClient.tsx hook to construct a StoryApi client
        - useStoryApi.tsx hook for interacting with the StoryApi using TanStack Query
      - components/
        - QueryClientProvider.tsx TanStack Query client provider
        - StoryApiProvider.tsx Provider for the StoryApi TanStack Query hook
      - main.tsx Instrument the QueryClientProvider and StoryApiProvider
    - .gitignore ignore generated client files
    - project.json updated to add targets for generating openapi hooks
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json updated to emit an openapi.json file

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

This hook can be used to make authenticated API requests to the `StoryApi`. As you can see in the implementation, it uses the `StoryApi` which is generated at build time and as such you will see an error in your IDE until we build our code. For more details on how the client is generated or how to consume the API, refer to the <Link path="guides/api-connection/react-fastapi">React to FastAPI guide</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

The above provider component uses the `useStoryApiClient` hook, and instantiates the `StoryApiOptionsProxy`, which is used to build options for TanStack Query hooks. You can use the corresponding hook `useStoryApi` to access this options proxy, which provides a way to interact with your FastAPI in a consistent manner to your tRPC API.

Since `useStoryApiClient` provides us with an async iterator for our streaming API, we will just use the vanilla client directly in this tutorial.

<Aside type="caution">
The `src/generated/story-api/*.gen.ts` files should never be modified manually as they will be re-generated every time you build your API.
</Aside>

</Drawer>

### Game UI: Connect to Game API

Now let's configure our Game UI to connect to our previously created Game API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> tRPC api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx sets up the GameAPI client
      - hooks/
        - **useGameApi.tsx** hooks to call the GameApi
      - **main.tsx** injects the trpc client providers
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useGameApi as useClient } from '../components/GameApiClientProvider';

export const useGameApi = useClient;
```

This hook uses tRPC's latest [React Query integration](https://trpc.io/blog/introducing-tanstack-react-query-client) allowing user's to interact with `@tanstack/react-query` directly without any additional layers of abstraction. For examples on how to call tRPC APIs, refer to the <Link path="guides/api-connection/react-trpc#using-the-generated-code">using the tRPC hook guide</Link>.

<Aside>
The `useGameApi` hook is different to the `useStoryApi` hook as it does not require a build in order for changes to be reflected courtesy of tRPC's usage of [Typescript inference](https://trpc.io/docs/concepts). This allows developers to make changes to their backend which instantly are reflected in their frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `main.tsx` file has been updated via an AST transform to inject the tRPC providers.

</Drawer>

### Game UI: Infrastructure

Now the final sub-project we need to create is for the CDK infrastructure. To create this, follow the below steps:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#infra updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#infra` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** cdk resources defined here
      - index.ts
      - **main.ts** entrypoint which defines all stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json add references
  - tsconfig.base.json add alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">If you are seeing an import error within your IDE, this is because our infrastructure project does not have a typescript reference set up yet in it's tsconfig.json. Nx has been [configured](https://nx.dev/nx-api/js/generators/typescript-sync) to create these references *dynamically* whenever a build/compile is run or if you run the `nx sync` command manually. For more information refer to the <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">Typescript guide</Link>.</Aside>

This is the entrypoint for your CDK application.

It is configured to use [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) to run infrastructure validation based on the configured ruleset. This is instrumented post synthesis.

<Aside type="tip">
There may be instances where you want to suppress certain rules on resources. You can do this in two ways:

###### Supress a rule on a given construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suppresses the RULE_NAME for the given construct.
suppressRule(construct, 'RULE_NAME');
```

###### Supress a rule on a descendant construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Supresses the RULE_NAME for the construct or any of its descendants if it is an instance of Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
```

This is where we will instantiate our CDK constructs to build our dungeon adventure game.

</Drawer>

#### Update our infrastructure

Let's make an update to our `packages/infra/src/stacks/application-stack.ts` to instantiate some of our already generated constructs:


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Notice here that we supply default integrations for our two APIs. By default, each operation in our API is mapped to an individual lambda function to handle that operation.

### Building our code

<Drawer title="Nx commands" trigger="Now it's time for us to build our code for the first time">
###### Single vs Multiple targets

The `run-many` command will run a target on multiple listed subprojects (`--all` will target them all). It will ensure dependencies are executed in the correct order.

You can also trigger a build (or any other task) for a single project target by running the target on the project directly. For example, if we want to build the `@dungeon-adventure/infra` project, you can run the following command:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizing your dependencies

You can also visualize your dependencies via:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx relies on [caching](https://nx.dev/concepts/how-caching-works) so that you can re-use artifacts from previous builds in order to speed up development. There is some configuration required to get this to work correctly and there may be cases where you want to perform a build **without using the cache**. To do that, simply append the `--skip-nx-cache` argument to your command. For example:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
If for whatever reason you ever wanted to clear your cache (stored in the `.nx` folder), you can run the following command:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

You should be prompted with the following:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

This message indicates that NX has detected some files which can be updated automatically for you. In this case, it is referring to the `tsconfig.json` files which do not have Typescript references set up on references projects. Select the **Yes, sync the changes and run the tasks** option to proceed. You should notice all of you IDE related import errors get automatically resolved as the sync generator will add the missing typescript references automatically!

<Aside type="tip">
If you encounter any lint errors, you can run the following command to automatically fix them.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Windows build failure">
<Drawer trigger="If you are on Windows and encounter a build error, click here." title="Windows build failure">
If you encounter a build/synth error for the `@dungeon-adventure/infra` project, this is expected as the library which instruments `cfn-guard` currently does not support Windows. There is a feature request tracking this, however in the meantime we can simply disable `cfn-guard` by modifying the `packages/infra/src/main.ts` file as follows:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

All built artifacts are now available within the `dist/` folder located at the root of the monorepo. This is a standard practice when using projects generated by the `@aws/nx-plugin` as it does not pollute your file-tree with generated files. In the event you want to clean yor files, you can simply delete the `dist/` folder without having to worry about generated files being littered throughout the file tree.

Congratulations! You’ve created all of the required sub-projects needed to start implementing the core of our Dunegeon Adventure game.  🎉🎉🎉