---
title: "tRPC"
description: "tRPC 的参考文档"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) 是一个用于在 TypeScript 中构建端到端类型安全 API 的框架。使用 tRPC 时，API 操作输入输出的变更会立即反映在客户端代码中，并可在 IDE 中直接查看，无需重新构建项目。

tRPC API 生成器会创建一个新的 tRPC API 并配置 AWS CDK 基础设施。生成的后端使用 AWS Lambda 进行无服务器部署，并通过 [Zod](https://zod.dev/) 实现模式验证。它配置了 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) 用于可观测性，包括日志记录、AWS X-Ray 追踪和 CloudWatch 指标。

## 使用方式

### 生成 tRPC API

可通过两种方式生成新的 tRPC API：

<RunGenerator generator="ts#trpc-api" />

### 选项参数

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## 生成器输出

生成器将在 `<directory>/<api-name>` 目录下创建以下项目结构：

<FileTree>
  - schema
    - src
      - index.ts 模式入口文件
      - procedures
        - echo.ts 使用 Zod 的 "echo" 过程共享模式定义
    - tsconfig.json TypeScript 配置
    - project.json 项目配置与构建目标
  - backend
    - src
      - init.ts 后端 tRPC 初始化
      - router.ts tRPC 路由定义（Lambda 处理程序 API 入口）
      - procedures API 暴露的过程（操作）
        - echo.ts 示例过程
      - middleware
        - error.ts 错误处理中间件
        - logger.ts 配置 AWS Powertools Lambda 日志的中间件
        - tracer.ts 配置 AWS Powertools Lambda 追踪的中间件
        - metrics.ts 配置 AWS Powertools Lambda 指标的中间件
      - local-server.ts 本地开发服务器使用的 tRPC 独立适配器入口
      - client
        - index.ts 机器间 API 调用的类型安全客户端
    - tsconfig.json TypeScript 配置
    - project.json 项目配置与构建目标
</FileTree>

生成器还会在 `packages/common/constructs` 目录中创建用于部署 API 的 CDK 构造。

## 实现 tRPC API

如上所示，tRPC API 包含两个主要组件：[`schema`](#schema) 和 [`backend`](#backend)，在您的工作区中定义为独立项目。

:::tip
`schema` 和 `backend` 均为 TypeScript 项目，更多通用用法可参考 <Link path="guides/typescript-project">TypeScript 项目文档</Link>。
:::

### 模式定义

schema 包定义了客户端与服务端代码共享的类型。这些类型使用 [Zod](https://zod.dev/)（一个 TypeScript 优先的模式声明与验证库）进行定义。

示例模式如下所示：

```ts
import { z } from 'zod';

// 模式定义
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 对应的 TypeScript 类型
export type User = z.TypeOf<typeof UserSchema>;
```

根据上述模式，`User` 类型等效于以下 TypeScript 代码：

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

模式由服务端和客户端代码共享，当需要修改 API 使用的数据结构时，只需在此处更新即可。

tRPC API 在运行时自动验证模式，无需在后端手动编写验证逻辑。

Zod 提供强大的模式组合与派生工具，如 `.merge`、`.pick`、`.omit` 等。更多信息请参阅 [Zod 文档网站](https://zod.dev/?id=basic-usage)。

### 后端实现

嵌套的 `backend` 文件夹包含 API 实现，您可在此定义 API 操作及其输入、输出和实现。

API 入口位于 `src/router.ts`，该文件包含 Lambda 处理程序，根据调用的操作将请求路由至对应"过程"。每个过程定义预期的输入、输出和实现。

生成的示例路由包含名为 `echo` 的单个操作：

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

示例 `echo` 过程生成于 `src/procedures/echo.ts`：

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

代码解析：

- `publicProcedure` 定义 API 的公共方法，包含 `src/middleware` 中配置的中间件。这些中间件包含用于日志、追踪和指标的 AWS Lambda Powertools 集成
- `input` 接受 Zod 模式，定义操作的预期输入。该操作的请求会自动根据此模式进行验证
- `output` 接受 Zod 模式，定义操作的预期输出。若实现返回不符合模式的输出，将出现类型错误
- `query` 接受定义操作实现的函数。该实现接收 `opts` 参数，包含传递给操作的 `input` 以及中间件设置的上下文（通过 `opts.ctx` 访问）。传递给 `query` 的函数必须返回符合 `output` 模式的输出

使用 `query` 定义实现表示该操作是非变更性的，用于定义数据检索方法。若要实现变更性操作，请改用 `mutation` 方法。

添加新操作后，请确保在 `src/router.ts` 的路由中注册。

## 自定义 tRPC API

### 错误处理

在实现中，可通过抛出 `TRPCError` 向客户端返回错误响应。这些错误接受表示错误类型的 `code`，例如：

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: '找不到请求的资源',
});
```

### 组织操作

随着 API 扩展，您可能需要对相关操作进行分组。

可使用嵌套路由对操作进行分组，例如：

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

客户端将接收此操作分组，例如调用上述 `listUsers` 操作：

```ts
client.users.list.query();
```

### 日志记录

AWS Lambda Powertools 日志记录器配置于 `src/middleware/logger.ts`，可通过 `opts.ctx.logger` 在 API 实现中访问。您可用此记录 CloudWatch 日志，或控制每个结构化日志消息的附加内容。例如：

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('操作调用输入', opts.input);

      return ...;
   });
```

更多日志记录器信息请参阅 [AWS Lambda Powertools 日志文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)。

### 记录指标

AWS Lambda Powertools 指标配置于 `src/middleware/metrics.ts`，可通过 `opts.ctx.metrics` 在 API 实现中访问。您可用此在 CloudWatch 中记录指标，无需导入 AWS SDK。例如：

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('调用次数', 'Count', 1);

      return ...;
   });
```

更多信息请参阅 [AWS Lambda Powertools 指标文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)。

### 精细化 X-Ray 追踪

AWS Lambda Powertools 追踪器配置于 `src/middleware/tracer.ts`，可通过 `opts.ctx.tracer` 在 API 实现中访问。您可用此添加 AWS X-Ray 追踪以深入了解 API 请求的性能和流程。例如：

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('我的算法');
      // ... 需要捕获的算法逻辑
      subSegment.close();

      return ...;
   });
```

更多信息请参阅 [AWS Lambda Powertools 追踪文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)。

### 实现自定义中间件

可通过实现中间件为过程上下文添加额外值。

例如，在 `src/middleware/identity.ts` 中实现中间件来从 API 提取调用用户详情。

首先定义要添加到上下文的内容：

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

注意我们在上下文中定义了附加的_可选_属性。tRPC 会确保在正确配置此中间件的过程中有此定义。

接下来实现中间件，结构如下：

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // 在这里添加在过程之前运行的逻辑

      const response = await opts.next(...);

      // 在这里添加在过程之后运行的逻辑

      return response;
   });
};
```

在本例中，我们需要提取调用 Cognito 用户的详情。通过从 API Gateway 事件中提取用户主题 ID（"sub"），并从 Cognito 获取用户详情。具体实现根据事件来自 REST API 或 HTTP API 有所不同：

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `无法确定调用用户`,
      });
    }

    const { Users } = await cognito.listUsers({
      // 假设用户池 ID 已配置在 Lambda 环境变量中
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `找不到主题 ID ${sub} 对应的用户`,
      });
    }

    // 向其他过程提供身份信息
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `无法确定调用用户`,
      });
    }

    const { Users } = await cognito.listUsers({
      // 假设用户池 ID 已配置在 Lambda 环境变量中
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `找不到主题 ID ${sub} 对应的用户`,
      });
    }

    // 向其他过程提供身份信息
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## 部署 tRPC API

tRPC 后端生成器在 `common/constructs` 文件夹中生成用于部署 API 的 CDK 构造。您可在 CDK 应用程序中使用，例如：

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // 将 API 添加到堆栈
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

此配置设置 API 基础设施，包括 AWS API Gateway REST/HTTP API、业务逻辑的 AWS Lambda 函数和 IAM 认证。

### 类型安全集成

<Snippet name="api/type-safe-api-integrations" />

:::tip
当您在 tRPC API 中添加或删除过程时，这些变更会立即反映在 CDK 构造中，无需重新构建。
:::

### 授权访问

可使用 `grantInvokeAccess` 方法授予 API 访问权限，例如授予认证的 Cognito 用户访问权限：

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## 本地 tRPC 服务器

使用 `serve` 目标运行 API 本地服务器，例如：

<NxCommands commands={['run @my-scope/my-api-backend:serve']} />

本地服务器入口位于 `src/local-server.ts`。

## 调用 tRPC API

可创建 tRPC 客户端以类型安全方式调用 API。若从其他后端调用 tRPC API，可使用 `src/client/index.ts` 中的客户端，例如：

```ts
import { createMyApiClient } from ':my-scope/my-api-backend';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

若从 React 网站调用 API，建议使用 <Link path="guides/api-connection/react-trpc">API 连接</Link> 生成器配置客户端。

## 更多信息

有关 tRPC 的更多信息，请参阅 [tRPC 文档](https://trpc.io/docs)。