---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de c√≥mo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## M√≥dulo 1: Configuraci√≥n del monorepo

Vamos a comenzar creando un nuevo monorepo. Desde el directorio de tu elecci√≥n, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurar√° un monorepo NX dentro del directorio `dungeon-adventure` que podr√°s abrir en vscode. Deber√≠a verse as√≠:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqu√≠ residir√°n tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura los valores predeterminados de la CLI de Nx y el monorepo
- package.json aqu√≠ se definen todas las dependencias de node
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json seg√∫n el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena pr√°ctica asegurarse de que todos los archivos no preparados est√©n confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qu√© ha cambiado despu√©s de ejecutar tu generador mediante `git diff`</Aside>

### API del Juego

Primero creemos nuestra API del Juego. Para hacer esto, creemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Deber√≠as ver que han aparecido algunos archivos nuevos en tu √°rbol de archivos.

<Aside>
El `package.json` ra√≠z ahora est√° configurado con un `type` de `module`, lo que significa que ESM es el tipo de m√≥dulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`. Para m√°s detalles sobre c√≥mo trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">gu√≠a ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructos CDK espec√≠ficos de la aplicaci√≥n
          - apis/
            - **game-api.ts** constructo CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructos CDK gen√©ricos
          - api/
            - rest-api.ts constructo base CDK para una API Rest de API Gateway
            - trpc-utils.ts utilidades para constructos CDK de API tRPC
            - utils.ts utilidades para constructos de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definici√≥n de interfaz usada tanto por CDK como por el sitio web
      - project.json
      - ...
  - game-api/
    - backend/ c√≥digo de implementaci√≥n tRPC
      - src/
        - client/ cliente vanilla t√≠picamente usado para llamadas m√°quina a m√°quina en ts
          - index.ts
          - sigv4.ts
        - middleware/ instrumentaci√≥n con powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementaciones espec√≠ficas para tus procedimientos/rutas de la API
          - **echo.ts**
        - index.ts
        - init.ts configura el contexto y middleware
        - local-server.ts usado al ejecutar el servidor tRPC localmente
        - **router.ts** punto de entrada para el manejador lambda que define todos los procedimientos
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Echemos un vistazo a algunos de los archivos clave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El enrutador define el punto de entrada para tu API tRPC y es el lugar donde declarar√°s todos tus m√©todos de API. Como puedes ver arriba, tenemos un m√©todo llamado `echo` con su implementaci√≥n en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementaci√≥n del m√©todo `echo` y como puedes ver est√° fuertemente tipado al declarar sus estructuras de datos de entrada y salida. Est√° importando estas definiciones del proyecto `:dungeon-adventure/game-api-schema` que es un [alias](https://www.typescriptlang.org/tsconfig/paths.html) para el proyecto de esquema.

<Aside type="tip">Si ves un error de importaci√≥n en tu IDE, es porque nuestro backend a√∫n no tiene una referencia de TypeScript configurada en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *din√°micamente* cuando se ejecuta un build/compile o si ejecutas manualmente el comando `nx sync`. Para m√°s informaci√≥n consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">gu√≠a de TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC est√°n definidas usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api-backend';

// Tipo de uni√≥n de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un constructo GameApi
 *
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operaci√≥n a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un constructo CDK que crea y configura una API REST de AWS API Gateway
 * espec√≠ficamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operaci√≥n como
   * su propia funci√≥n lambda individual.
   *
   * @param scope - El alcance del constructo CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/backend/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aqu√≠ permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir aqu√≠ acceso m√°quina a m√°quina granular usando principios m√°s espec√≠ficos (ej. roles o
          // usuarios) y recursos (ej. qu√© rutas de API pueden ser invocadas por qu√© principio) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el constructo CDK que define nuestro GameApi. Como puedes ver, proporciona un m√©todo `defaultIntegrations` que crea autom√°ticamente una funci√≥n lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementaci√≥n de la API empaquetada. Esto significa que en el momento de `cdk synth` no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

</Drawer>

### API de Historia

Ahora creemos nuestra API de Historia. Para hacer esto, creemos una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Deber√≠as ver que han aparecido algunos archivos nuevos en tu √°rbol de archivos.
<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `py#fast-api`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- .venv/ entorno virtual √∫nico para el monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructos CDK espec√≠ficos de la aplicaci√≥n
          - apis/
            - **story-api.ts** constructo CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para agregar una dependencia de build en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para agregar el StoryApi
  - story_api/
    - story_api/ m√≥dulo python
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada para la lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versi√≥n de python fijada por uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propiedades para crear un constructo StoryApi
 *
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operaci√≥n a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un constructo CDK que crea y configura una API REST de AWS API Gateway
 * espec√≠ficamente para StoryApi.
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operaci√≥n como
   * su propia funci√≥n lambda individual.
   *
   * @param scope - El alcance del constructo CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aqu√≠ permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir aqu√≠ acceso m√°quina a m√°quina granular usando principios m√°s espec√≠ficos (ej. roles o
          // usuarios) y recursos (ej. qu√© rutas de API pueden ser invocadas por qu√© principio) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Este es el constructo CDK que define nuestro StoryApi. Como puedes ver, proporciona un m√©todo `defaultIntegrations` que crea autom√°ticamente una funci√≥n lambda para cada operaci√≥n definida en nuestra FastAPI, apuntando a la implementaci√≥n de la API empaquetada. Esto significa que en el momento de `cdk synth` no ocurre empaquetado (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aqu√≠ hay un ejemplo del generador realizando una transformaci√≥n AST que preserva todo el c√≥digo existente y realiza una actualizaci√≥n. Aqu√≠ puedes ver que se agreg√≥ `StoryApi` a la definici√≥n de `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¬°impondr√° seguridad de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aqu√≠ es donde se definir√°n todos tus m√©todos de API. Como puedes ver aqu√≠, tenemos un m√©todo `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar las entradas y salidas de tus m√©todos y garantizar seguridad de tipos.

</Drawer>

### Interfaz de Juego: Sitio Web

Ahora creemos la interfaz de usuario que te permitir√° interactuar con el juego. Para hacer esto, creemos un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Deber√≠as ver que han aparecido algunos archivos nuevos en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `ts#cloudscape-website`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructos CDK espec√≠ficos de la aplicaci√≥n
          - static-websites/
            - **game-ui.ts** constructo CDK para crear tu Game UI
        - core/
          - static-website.ts constructo gen√©rico para sitio web est√°tico
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts dise√±o general de la p√°gina: encabezado, pie, barra lateral, etc.
          - navitems.ts elementos de navegaci√≥n de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar din√°micamente notificaciones, estilo de p√°gina, etc.
      - routes/ rutas basadas en archivos de @tanstack/react-router
        - index.tsx p√°gina ra√≠z '/' redirige a '/welcome'
        - __root.tsx todas las p√°ginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza autom√°ticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el constructo CDK que define nuestro GameUI. Como puedes ver, ya est√° configurada la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en el momento de `build` el empaquetado ocurre dentro del target de build del proyecto game-ui y su salida se usa aqu√≠.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuraci√≥n de [`enrutamiento-basado-en-archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo est√© en ejecuci√≥n, puedes simplemente crear archivos en la carpeta `routes` y `@tanstack/react-router` crear√° la configuraci√≥n de archivos necesaria para ti, actualizando tambi√©n el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera segura en tipos, lo que significa que cuando uses `<Link>`, la opci√≥n `to` solo mostrar√° rutas v√°lidas. Para m√°s informaci√≥n, consulta la [documentaci√≥n de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizar√° al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionar√° la `Route` por ti cuando crees/muevas este archivo (mientras el servidor de desarrollo est√© en ejecuci√≥n). Esto se mostrar√° en una secci√≥n posterior de este tutorial.

</Drawer>

### Interfaz de Juego: Autenticaci√≥n

Ahora configuremos nuestra Interfaz de Juego para requerir acceso autenticado mediante Amazon Cognito siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Deber√≠as ver que han aparecido/cambiado algunos archivos nuevos en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website#auth" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `ts#cloudscape-website#auth`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts constructo CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario logueado/logout al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesi√≥n en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo proporciona a los hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` se han agregado al archivo `main.tsx` mediante una transformaci√≥n AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuraci√≥n de conexi√≥n de Cognito necesaria para realizar las llamadas al backend al destino correcto.

</Drawer>

### Interfaz de Juego: Conectar a Story API

Ahora configuremos nuestra Interfaz de Juego para conectarse a nuestra Story API creada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Deber√≠as ver que han aparecido/cambiado algunos archivos nuevos en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por la conexi√≥n UI -> FastAPI" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar requests
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx Proveedor para el hook de TanStack Query de StoryApi
      - main.tsx Instrumenta QueryClientProvider y StoryApiProvider
    - .gitignore ignora archivos de cliente generados
    - project.json actualizado para agregar targets de generaci√≥n de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir un archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Este hook puede usarse para hacer requests autenticadas a la `StoryApi`. Como puedes ver en la implementaci√≥n, usa el `StoryApi` que se genera en tiempo de build, por lo que ver√°s un error en tu IDE hasta que compilemos nuestro c√≥digo. Para m√°s detalles sobre c√≥mo se genera el cliente o c√≥mo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">gu√≠a React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una manera de interactuar con tu FastAPI de forma consistente con tu API tRPC.

Dado que `useStoryApiClient` nos proporciona un iterador as√≠ncrono para nuestra API de streaming, en este tutorial usaremos directamente el cliente vanilla.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerar√°n cada vez que construyas tu API.
</Aside>

</Drawer>

### Interfaz de Juego: Conectar a Game API

Ahora configuremos nuestra Interfaz de Juego para conectarse a nuestra Game API creada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Deber√≠as ver que han aparecido/cambiado algunos archivos nuevos en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por la conexi√≥n UI -> tRPC" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx todas las APIs tRPC configuradas
          - TrpcClientProviders.tsx crea un proveedor de cliente por API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hooks para llamar a GameApi
      - **main.tsx** inyecta los proveedores de cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Este hook usa la √∫ltima [integraci√≥n de React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC, permitiendo a los usuarios interactuar directamente con `@tanstack/react-query` sin capas adicionales de abstracci√≥n. Para ejemplos de c√≥mo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">gu√≠a de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` porque no requiere un build para que los cambios se reflejen gracias al uso que hace tRPC de la [inferencia de TypeScript](https://trpc.io/docs/concepts). Esto permite a los desarrolladores hacer cambios en su backend que se reflejen instant√°neamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformaci√≥n AST para inyectar los proveedores tRPC.

</Drawer>

### Infraestructura de la Interfaz de Juego

Ahora el √∫ltimo subproyecto que necesitamos crear es para la infraestructura CDK. Para crear esto, sigue estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deber√≠as ver que han aparecido/cambiado algunos archivos nuevos en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqu√≠
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregar referencias
  - tsconfig.base.json agregar alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Este es el punto de entrada para tu aplicaci√≥n CDK.

Est√° configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para ejecutar validaciones de infraestructura basadas en el conjunto de reglas configurado. Esto se instrumenta post s√≠ntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacer esto de dos maneras:

###### Suprimir una regla en un constructo dado

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el constructo dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un constructo descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el constructo o cualquiera de sus descendientes si es una instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Aqu√≠ va el c√≥digo que define tu stack
  }
}
```

Aqu√≠ es donde instanciaremos nuestros constructos CDK para construir nuestro juego de aventuras.

</Drawer>

#### Actualizar nuestra infraestructura

Hagamos una actualizaci√≥n en nuestro `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructos ya generados:


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota aqu√≠ que proporcionamos integraciones predeterminadas para nuestras dos APIs. Por defecto, cada operaci√≥n en nuestra API est√° mapeada a una funci√≥n lambda individual para manejar esa operaci√≥n.

### Construyendo nuestro c√≥digo

<Drawer title="Comandos de Nx" trigger="Ahora es el momento de construir nuestro c√≥digo por primera vez">
###### Targets √∫nicos vs m√∫ltiples

El comando `run-many` ejecutar√° un target en m√∫ltiples subproyectos listados (`--all` los seleccionar√° todos). Se asegurar√° de que las dependencias se ejecuten en el orden correcto.

Tambi√©n puedes activar un build (o cualquier otra tarea) para un target de proyecto √∫nico ejecutando el target en el proyecto directamente. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizaci√≥n de dependencias

Tambi√©n puedes visualizar tus dependencias mediante:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cach√©

Nx depende del [cach√©](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuraci√≥n para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar el cach√©**. Para hacer esto, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por cualquier raz√≥n quisieras limpiar tu cach√© (almacenado en la carpeta `.nx`), puedes ejecutar:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Deber√≠as ver el siguiente mensaje:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse autom√°ticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de TypeScript configuradas en los proyectos referenciados. Selecciona la opci√≥n **Yes, sync the changes and run the tasks** para continuar. Deber√≠as notar que todos los errores de importaci√≥n relacionados con tu IDE se resuelven autom√°ticamente, ya que el generador de sincronizaci√≥n agregar√° las referencias de TypeScript faltantes.

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos autom√°ticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Error de build en Windows">
<Drawer trigger="Si est√°s en Windows y encuentras un error de build, haz clic aqu√≠." title="Error de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la librer√≠a que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de feature para esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` de la siguiente manera:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos los artefactos construidos ahora est√°n disponibles dentro de la carpeta `dist/` ubicada en la ra√≠z del monorepo. Esta es una pr√°ctica est√°ndar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu √°rbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, simplemente puedes eliminar la carpeta `dist/` sin preocuparte por archivos generados esparcidos por el √°rbol de archivos.

¬°Felicidades! Has creado todos los subproyectos necesarios para comenzar a implementar el n√∫cleo de nuestro juego de Aventura en el Calabozo.  üéâüéâüéâ