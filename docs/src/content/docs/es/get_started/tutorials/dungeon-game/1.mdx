---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA usando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configuración del monorepositorio

Comenzaremos creando un nuevo monorepositorio. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurará un monorepositorio NX dentro del directorio `dungeon-adventure` que podrás abrir en VSCode. Debería verse así:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura los valores predeterminados de la CLI de Nx y el monorepositorio
- package.json aquí se definen todas las dependencias de Node
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en Node extienden este archivo
- tsconfig.json
</FileTree>

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena práctica asegurarse de que todos los archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar tu generador mediante `git diff`</Aside>

### API del Juego

Primero creemos nuestra API del Juego. Para esto, crearemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en Node proporcionados por el `@aws/nx-plugin`. Para más detalles sobre cómo trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **game-api.ts** constructo CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - api/
            - rest-api.ts constructo base CDK para una API Rest de API Gateway
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada tanto por CDK como por el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla típicamente usado para llamadas máquina a máquina en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentación con Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas para tu API
        - **echo.ts**
      - procedures/ implementaciones específicas de los procedimientos/rutas de tu API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Echemos un vistazo a algunos de los archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada para tu API tRPC y es donde declararás todos los métodos de tu API. Como puedes ver arriba, tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementación del método `echo` y como puedes ver está fuertemente tipado al declarar sus estructuras de datos de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo de unión de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un constructo GameApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un constructo CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del constructo CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir acceso detallado máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principal) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight no autenticadas
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el constructo CDK que define nuestro GameApi. Como puedes ver, proporciona un método `defaultIntegrations` que crea automáticamente una función lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del objetivo de compilación del proyecto backend.

</Drawer>

### API de la Historia

Ahora creemos nuestra API de la Historia. Para esto, crearemos una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.
<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `py#fast-api`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- .venv/ entorno virtual único para el monorepositorio
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **story-api.ts** constructo CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para agregar una dependencia de compilación en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para agregar el StoryApi
  - story_api/
    - story_api/ módulo Python
      - init.py configura Powertools, FastAPI y middleware
      - **main.py** punto de entrada para la lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versión de Python fijada para uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propiedades para crear un constructo StoryApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un constructo CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para StoryApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del constructo CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir acceso detallado máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principal) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight no autenticadas
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Este es el constructo CDK que define nuestro StoryApi. Como puedes ver, proporciona un método `defaultIntegrations` que crea automáticamente una función lambda para cada operación definida en nuestra FastAPI, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del objetivo de compilación del proyecto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aquí hay un ejemplo del generador realizando una transformación AST que preserva todo el código existente y realiza una actualización. Puedes ver que se agregó `StoryApi` a la definición de `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¡se aplicará la seguridad de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aquí es donde se definirán todos tus métodos de API. Como puedes ver aquí, tenemos un método `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar las entradas y salidas de tus métodos y garantizar la seguridad de tipos.

</Drawer>

### Interfaz de Usuario del Juego: Sitio Web

Ahora creemos la interfaz de usuario que te permitirá interactuar con el juego. Para esto, creemos un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#cloudscape-website`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - static-websites/
            - **game-ui.ts** constructo CDK para crear tu Game UI
        - core/
          - static-website.ts constructo genérico para sitio web estático
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts diseño general de la página: encabezado, pie, barra lateral, etc.
          - navitems.ts elementos de navegación de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar dinámicamente notificaciones, estilo de página, etc.
      - routes/ rutas basadas en archivos de @tanstack/react-router
        - index.tsx página raíz '/' redirige a '/welcome'
        - __root.tsx todas las páginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza automáticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el constructo CDK que define nuestro GameUI. Como puedes ver, ya está configurada la ruta al paquete generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del objetivo de compilación del proyecto game-ui y su salida se usa aquí.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutamiento basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo esté en ejecución, simplemente puedes crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` creará la configuración de archivos necesaria y actualizará el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera segura en tipos, lo que significa que cuando uses `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la [documentación de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Bienvenido</Header>}>
      <SpaceBetween size="l">
        <Container>¡Bienvenido a tu nuevo sitio web Cloudscape!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizará al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionará la `Route` por ti cada vez que crees/muevas este archivo (siempre que el servidor de desarrollo esté en ejecución). Esto se mostrará en una sección posterior de este tutorial.

</Drawer>

### Interfaz de Usuario del Juego: Autenticación

Ahora configuremos nuestra Game UI para requerir acceso autenticado mediante Amazon Cognito siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#cloudscape-website#auth" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#cloudscape-website#auth`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts constructo CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario conectado/cierre de sesión al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesión en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` se han agregado al archivo `main.tsx` mediante una transformación AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuración de conexión de Cognito necesaria para realizar las llamadas al backend al destino correcto.

</Drawer>

### Interfaz de Usuario del Juego: Conectar a Story API

Ahora configuremos nuestra Game UI para conectarse a nuestra Story API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por la conexión UI -> FastAPI" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar solicitudes
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx Proveedor para el hook TanStack Query de StoryApi
      - main.tsx Instrumenta QueryClientProvider y StoryApiProvider
    - .gitignore ignora archivos de cliente generados
    - project.json actualizado para agregar objetivos de generación de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir un archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Este hook se puede usar para hacer solicitudes de API autenticadas a `StoryApi`. Como puedes ver en la implementación, usa el `StoryApi` que se genera en tiempo de compilación, por lo que verás un error en tu IDE hasta que compilemos nuestro código. Para más detalles sobre cómo se genera el cliente o cómo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">guía de React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una manera de interactuar con tu FastAPI de manera consistente con tu API tRPC.

Dado que `useStoryApiClient` nos proporciona un iterador asíncrono para nuestra API de streaming, en este tutorial usaremos directamente el cliente vanilla.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerarán cada vez que construyas tu API.
</Aside>

</Drawer>

### Interfaz de Usuario del Juego: Conectar a Game API

Ahora configuremos nuestra Game UI para conectarse a nuestra Game API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por la conexión UI -> tRPC" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura el cliente GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para llamar a GameApi
      - **main.tsx** inyecta los proveedores del cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useGameApi as useClient } from '../components/GameApiClientProvider';

export const useGameApi = useClient;
```

Este hook usa la última [integración de React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC, permitiendo a los usuarios interactuar directamente con `@tanstack/react-query` sin capas adicionales de abstracción. Para ejemplos de cómo llamar a las APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` porque no requiere una compilación para que los cambios se reflejen, gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejen instantáneamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` se ha actualizado mediante una transformación AST para inyectar los proveedores de tRPC.

</Drawer>

### Infraestructura de la Interfaz de Usuario del Juego

Ahora el último subproyecto que necesitamos crear es para la infraestructura CDK. Para crearlo, sigue estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aquí
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregar referencias
  - tsconfig.base.json agregar alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume las credenciales de tu CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Si ves un error de importación en tu IDE, es porque nuestro proyecto de infraestructura aún no tiene una referencia TypeScript configurada en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cada vez que se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de TypeScript</Link>.</Aside>

Este es el punto de entrada para tu aplicación CDK.

Está configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) y ejecutar validación de infraestructura basada en el conjunto de reglas configurado. Esto se instrumenta post síntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacer esto de dos maneras:

###### Suprimir una regla en un constructo dado

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el constructo dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un constructo descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el constructo o cualquiera de sus descendientes si es una instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El código que define tu stack va aquí
  }
}
```

Aquí es donde instanciaremos nuestros constructos CDK para construir nuestro juego de aventuras.

</Drawer>

#### Actualizar nuestra infraestructura

Actualicemos nuestro `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructos ya generados:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Observa que aquí proporcionamos integraciones predeterminadas para nuestras dos APIs. Por defecto, cada operación en nuestra API se mapea a una función lambda individual para manejar esa operación.

### Construyendo nuestro código

<Drawer title="Comandos de Nx" trigger="Ahora es momento de construir nuestro código por primera vez">
###### Objetivos únicos vs múltiples

El comando `run-many` ejecutará un objetivo en múltiples subproyectos listados (`--all` los seleccionará todos). Se asegurará de que las dependencias se ejecuten en el orden correcto.

También puedes activar un build (o cualquier otra tarea) para un objetivo de proyecto único ejecutando el objetivo directamente en el proyecto. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar el siguiente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando tus dependencias

También puedes visualizar tus dependencias mediante:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caché

Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds anteriores y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la caché**. Para eso, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna razón quisieras limpiar tu caché (almacenada en la carpeta `.nx`), puedes ejecutar el siguiente comando:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Deberías recibir el siguiente mensaje:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de TypeScript configuradas en proyectos referenciados. Selecciona la opción **Yes, sync the changes and run the tasks** para continuar. Deberías notar que todos los errores de importación en tu IDE se resuelven automáticamente, ya que el generador de sincronización agregará las referencias de TypeScript faltantes.

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Error de compilación en Windows">
<Drawer trigger="Si estás en Windows y encuentras un error de compilación, haz clic aquí." title="Error de compilación en Windows">
Si encuentras un error de compilación/síntesis para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la biblioteca que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de función rastreando esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` de la siguiente manera:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume las credenciales de tu CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos los artefactos construidos están ahora disponibles dentro de la carpeta `dist/` ubicada en la raíz del monorepositorio. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu árbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, simplemente puedes eliminar la carpeta `dist/` sin preocuparte por archivos generados esparcidos por el árbol de directorios.

¡Felicidades! Has creado todos los subproyectos necesarios para comenzar a implementar el núcleo de nuestro juego Dunegeon Adventure.  🎉🎉🎉