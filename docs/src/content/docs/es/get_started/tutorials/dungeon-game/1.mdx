---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de c贸mo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## M贸dulo 1: Configuraci贸n del monorepo

Comenzaremos creando un nuevo monorepo. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurar谩 un monorepo NX dentro del directorio `dungeon-adventure` que podr谩s abrir en vscode. Deber铆a verse as铆:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqu铆 residir谩n tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura los valores predeterminados de Nx CLI y el monorepo
- package.json aqu铆 se definen todas las dependencias de node
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json seg煤n el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Ahora estamos listos para crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena pr谩ctica asegurarse de que todos los archivos no preparados est茅n confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qu茅 ha cambiado despu茅s de ejecutar el generador mediante `git diff`</Aside>

### API del Juego

Primero creemos nuestra API del Juego. Para esto, crearemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Deber铆as ver nuevos archivos en tu 谩rbol de directorios.

<Aside>
El `package.json` ra铆z ahora est谩 configurado con un `type` de `module`, lo que significa que ESM es el tipo de m贸dulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`. Para m谩s detalles sobre proyectos TypeScript, consulta la <Link path="guides/typescript-project">gu铆a ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aqu铆 para examinar estos archivos en detalle.">
A continuaci贸n se muestra la lista de archivos generados por el generador `ts#trpc-api`. Examinaremos algunos archivos clave resaltados en el 谩rbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec铆ficos de la aplicaci贸n
          - apis/
            - **game-api.ts** constructo CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen茅ricos
          - api/
            - rest-api.ts constructo base para API Gateway Rest API
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definici贸n de interfaz usada por CDK y el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla para llamadas m谩quina a m谩quina
        - index.ts
        - sigv4.ts
      - middleware/ instrumentaci贸n con powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas de la API
        - **echo.ts**
      - procedures/ implementaciones de los procedimientos/rutas de la API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada del lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Observemos algunos archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El enrutador define el punto de entrada de tu API tRPC y es donde declarar谩s todos los m茅todos de la API. Como se ve arriba, tenemos un m茅todo llamado `echo` cuya implementaci贸n est谩 en `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo implementa el m茅todo `echo` y define fuertemente los tipos mediante esquemas de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todos los esquemas tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

type Operations = Procedures<AppRouter>;

export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  integrations: TIntegrations;
}

export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el constructo CDK que define nuestra GameApi. El m茅todo `defaultIntegrations` crea autom谩ticamente una funci贸n lambda para cada procedimiento de la API tRPC, apuntando al c贸digo ya empaquetado.

</Drawer>

### API de Historia

Ahora creemos nuestra API de Historia. Para esto, crearemos una API Fast llamada `StoryApi`:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Ver谩s nuevos archivos en tu 谩rbol de directorios.
<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aqu铆 para examinar estos archivos en detalle.">
Archivos clave generados por `py#fast-api`:
<FileTree>
- .venv/ entorno virtual 煤nico para el monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ 
          - apis/
            - **story-api.ts** constructo CDK para la API Fast
            - index.ts actualizado para exportar story-api
      - project.json actualizado con dependencia de build en story_api
    - types/
      - src/
        - **runtime-config.ts** actualizado con StoryApi
  - story_api/
    - story_api/ m贸dulo Python
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada lambda con todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
- .python-version versi贸n fijada de Python
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
// (Implementaci贸n similar a game-api.ts adaptada para Python)
```

Este constructo CDK define nuestra StoryApi, creando funciones lambda para cada operaci贸n de FastAPI.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

El generador actualiz贸 `IRuntimeConfig` para incluir StoryApi, asegurando seguridad de tipos en el frontend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aqu铆 se definen los m茅todos de la API usando [Pydantic](https://docs.pydantic.dev/latest/) para seguridad de tipos.

</Drawer>

### Interfaz del Juego: Sitio Web

Creemos la interfaz de usuario con estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Ver谩s nuevos archivos en tu 谩rbol.
<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic para detalles.">
<FileTree>
- packages/
  - game-ui/
    - src/
      - routes/ 
        - welcome/
          - **index.tsx** componente para la ruta /welcome
</FileTree>

```tsx
// packages/game-ui/src/main.tsx
// Configuraci贸n de React con enrutamiento
```

Este componente se renderiza en la ruta `/welcome` usando enrutamiento basado en archivos.

</Drawer>

### Interfaz del Juego: Autenticaci贸n

Habilitemos autenticaci贸n con Cognito:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

<Drawer title="Archivos actualizados por autenticaci贸n" trigger="Detalles aqu铆.">
Se a帽adieron componentes para autenticaci贸n y proveedores de configuraci贸n.
</Drawer>

### Conexi贸n UI a Story API

Conectemos la UI a Story API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

<Drawer title="Conexi贸n UI-FastAPI" trigger="Ver detalles.">
Se generaron hooks y proveedores para consumir la API usando TanStack Query.
</Drawer>

### Conexi贸n UI a Game API

Conectemos la UI a Game API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

<Drawer title="Conexi贸n UI-tRPC" trigger="Detalles aqu铆.">
Integraci贸n de tRPC con React Query para acceso tipo-safe a la API.
</Drawer>

### Infraestructura del Juego

Creemos la infraestructura CDK:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

<Drawer title="Archivos de infraestructura" trigger="Examinar cambios.">
Configuraci贸n de stacks CDK con validaci贸n de reglas CloudFormation.
</Drawer>

#### Actualizar infraestructura

Actualicemos `application-stack.ts` para instanciar nuestros constructs:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

### Construir el c贸digo

<Drawer title="Comandos Nx" trigger="Instrucciones de construcci贸n">
Usa `run-many` para construir todos los proyectos o objetivos espec铆ficos.

<NxCommands commands={['run-many --target build --all']} />

Alerta de sincronizaci贸n TypeScript: selecciona **S铆** para actualizar referencias autom谩ticamente.

<Aside type="caution" title="Error en Windows">
<Drawer trigger="Soluci贸n para Windows" title="Error de build en Windows">
Deshabilita temporalmente cfn-guard modificando `main.ts`.
</Drawer>
</Aside>
</Drawer>

隆Felicidades! Has creado todos los subproyectos necesarios para tu juego. 