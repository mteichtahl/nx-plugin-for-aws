---
title: "React a FastAPI"
description: "Conectar un sitio web de React a un FastAPI de Python"
---



import { FileTree, Steps } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import schema from '../../../../../../../packages/nx-plugin/src/api-connection/schema.json';

El generador `api-connection` proporciona una forma rápida de integrar tu aplicación React con tu backend FastAPI. Configura toda la configuración necesaria para conectarse a tus backends FastAPI de manera tipada, incluyendo generación de clientes y hooks de [TanStack Query](https://tanstack.com/query/v5), soporte para autenticación AWS IAM y manejo adecuado de errores.

## Requisitos previos

Antes de usar este generador, asegúrate que tu aplicación React tenga:

1. Un archivo `main.tsx` que renderice tu aplicación
2. Un backend FastAPI funcional (generado usando el generador FastAPI)

<details>
<summary>Ejemplo de estructura requerida para `main.tsx`</summary>

```tsx
import { StrictMode } from 'react';
import * as ReactDOM from 'react-dom/client';
import App from './app/app';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement,
);
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

</details>

## Uso

### Ejecutar el generador

<RunGenerator generator="api-connection" />

### Opciones

<GeneratorParameters schema={schema} />

## Salida del generador

El generador modificará los siguientes archivos en tu proyecto FastAPI:

<FileTree>

- scripts
  - generate_open_api.py Añade un script que genera la especificación OpenAPI para tu API
- project.json Se añade un nuevo target al build que invoca el script de generación

</FileTree>

El generador modificará los siguientes archivos en tu aplicación React:

<FileTree>

- src
  - components
    - \<ApiName>Provider.tsx Proveedor para el cliente de tu API
    - QueryClientProvider.tsx Proveedor del cliente TanStack React Query
  - hooks
    - use\<ApiName>.tsx Añade un hook para llamar a tu API con estado gestionado por TanStack Query
    - use\<ApiName>Client.tsx Añade un hook para instanciar el cliente vanilla que puede llamar a tu API
    - useSigV4.tsx Añade un hook para firmar peticiones HTTP con SigV4 (si seleccionaste autenticación IAM)
- project.json Se añade un nuevo target al build que genera el cliente tipado
- .gitignore Los archivos generados del cliente se ignoran por defecto

</FileTree>

El generador también añadirá Runtime Config a la infraestructura de tu sitio web si no existe, asegurando que la URL de la API para FastAPI esté disponible en el sitio y configurada automáticamente por el hook `use<ApiName>.tsx`.

### Generación de código

Durante el build, se genera un cliente tipado a partir de la especificación OpenAPI de tu FastAPI. Esto añadirá tres nuevos archivos a tu aplicación React:

<FileTree>

- src
  - generated
    - \<ApiName>
      - types.gen.ts Tipos generados de los modelos pydantic definidos en tu FastAPI
      - client.gen.ts Cliente tipado para llamar a tu API
      - options-proxy.gen.ts Provee métodos para crear opciones de hooks TanStack Query que interactúan con tu API

</FileTree>

:::tip
Por defecto, el cliente generado se ignora en control de versiones. Si prefieres incluirlo, puedes eliminar la entrada del archivo `.gitignore` de tu aplicación React, pero ten en cuenta que cualquier cambio manual en los archivos `.gen.ts` se sobrescribirá al construir el proyecto.
:::

## Usando el código generado

El cliente tipado generado puede usarse para llamar a tu FastAPI desde la aplicación React. Se recomienda usar los hooks de TanStack Query, pero también puedes usar el cliente vanilla si prefieres.

:::note
Cada vez que modifiques tu FastAPI, debes reconstruir tu proyecto para que los cambios se reflejen en el cliente generado. Por ejemplo:

<NxCommands commands={['run-many --target build --all']} />
:::

:::tip
Si estás trabajando simultáneamente en tu aplicación React y FastAPI, puedes usar [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) para regenerar el cliente cada vez que hagas cambios en la API:

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <WebsiteProject>:"generate:<ApiName>-client"',
  ]}
/>
:::

### Usando el hook de la API

El generador provee un hook `use<ApiName>` que puedes usar para llamar a tu API con TanStack Query.

### Consultas

Puedes usar el método `queryOptions` para obtener las opciones requeridas para llamar a la API usando el hook `useQuery` de TanStack Query:

```tsx {7}
import { useQuery } from '@tanstack/react-query';
import { useState, useEffect } from 'react';
import { useMyApi } from './hooks/useMyApi';

function MyComponent() {
  const api = useMyApi();
  const item = useQuery(api.getItem.queryOptions({ itemId: 'some-id' }));

  if (item.isLoading) return <div>Loading...</div>;
  if (item.isError) return <div>Error: {item.error.message}</div>;

  return <div>Item: {item.data.name}</div>;
}
```

<Drawer title="Usar el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente vanilla directamente.">
```tsx {5,13}
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function MyComponent() {
  const api = useMyApiClient();
  const [item, setItem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchItem = async () => {
      try {
        const data = await api.getItem({ itemId: 'some-id' });
        setItem(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchItem();
  }, [api]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>Item: {item.name}</div>;
}
```
</Drawer>

### Mutaciones

Los hooks generados incluyen soporte para mutaciones usando el hook `useMutation` de TanStack Query. Esto provee una forma limpia de manejar operaciones de creación, actualización y eliminación con estados de carga, manejo de errores y actualizaciones optimistas.

```tsx {5-7,11}
import { useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function CreateItemForm() {
  const api = useMyApi();
  // Crear una mutación usando las opciones generadas
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleSubmit = (e) => {
    e.preventDefault();
    createItem.mutate({ name: 'New Item', description: 'A new item' });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Campos del formulario */}
      <button
        type="submit"
        disabled={createItem.isPending}
      >
        {createItem.isPending ? 'Creando...' : 'Crear ítem'}
      </button>

      {createItem.isSuccess && (
        <div className="success">
          Ítem creado con ID: {createItem.data.id}
        </div>
      )}

      {createItem.isError && (
        <div className="error">
          Error: {createItem.error.message}
        </div>
      )}
    </form>
  );
}
```

También puedes añadir callbacks para diferentes estados de la mutación:

```tsx
const createItem = useMutation({
  ...api.createItem.mutationOptions(),
  onSuccess: (data) => {
    // Se ejecuta cuando la mutación tiene éxito
    console.log('Ítem creado:', data);
    // Puedes navegar al nuevo ítem
    navigate(`/items/${data.id}`);
  },
  onError: (error) => {
    // Se ejecuta cuando la mutación falla
    console.error('Error al crear ítem:', error);
  },
  onSettled: () => {
    // Se ejecuta cuando la mutación finaliza (éxito o error)
    // Buen lugar para invalidar consultas afectadas
    queryClient.invalidateQueries({ queryKey: api.listItems.queryKey() });
  }
});
```

<Drawer title="Mutaciones usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
import { useState } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function CreateItemForm() {
  const api = useMyApiClient();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [createdItem, setCreatedItem] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      const newItem = await api.createItem({
        name: 'New Item',
        description: 'A new item'
      });
      setCreatedItem(newItem);
      // Puedes navegar al nuevo ítem
      // navigate(`/items/${newItem.id}`);
    } catch (err) {
      setError(err);
      console.error('Error al crear ítem:', err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Campos del formulario */}
      <button
        type="submit"
        disabled={isLoading}
      >
        {isLoading ? 'Creando...' : 'Crear ítem'}
      </button>

      {createdItem && (
        <div className="success">
          Ítem creado con ID: {createdItem.id}
        </div>
      )}

      {error && (
        <div className="error">
          Error: {error.message}
        </div>
      )}
    </form>
  );
}
```
</Drawer>

### Paginación con consultas infinitas

Para endpoints que aceptan un parámetro `cursor`, los hooks generados proveen soporte para consultas infinitas usando el hook `useInfiniteQuery` de TanStack Query. Esto facilita implementar funcionalidad de "cargar más" o scroll infinito.

```tsx {5-14,24-26}
import { useInfiniteQuery } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function ItemList() {
  const api = useMyApi();
  const items = useInfiniteQuery({
    ...api.listItems.infiniteQueryOptions({
      limit: 10, // Número de ítems por página
    }, {
      // Asegúrate de definir una función getNextPageParam que retorne
      // el parámetro que se pasará como 'cursor' para la próxima página
      getNextPageParam: (lastPage) =>
        lastPage.nextCursor || undefined
      }),
  });

  if (items.isLoading) {
    return <LoadingSpinner />;
  }

  if (items.isError) {
    return <ErrorMessage message={items.error.message} />;
  }

  return (
    <div>
      {/* Aplanar el array de páginas para renderizar todos los ítems */}
      <ul>
        {items.data.pages.flatMap(page =>
          page.items.map(item => (
            <li key={item.id}>{item.name}</li>
          ))
        )}
      </ul>

      <button
        onClick={() => items.fetchNextPage()}
        disabled={!items.hasNextPage || items.isFetchingNextPage}
      >
        {items.isFetchingNextPage
          ? 'Cargando más...'
          : items.hasNextPage
          ? 'Cargar más'
          : 'No hay más ítems'}
      </button>
    </div>
  );
}
```

Los hooks generados manejan automáticamente la paginación basada en cursor si tu API lo soporta. El valor `nextCursor` se extrae de la respuesta y se usa para obtener la próxima página.

:::tip
Si tienes una API paginada cuyo parámetro de paginación tiene un nombre distinto a `cursor`, puedes [personalizarlo usando la extensión OpenAPI `x-cursor`](#custom-pagination-cursor).
:::

<Drawer title="Paginación usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function ItemList() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [nextCursor, setNextCursor] = useState(null);
  const [isFetchingMore, setIsFetchingMore] = useState(false);

  // Obtener datos iniciales
  useEffect(() => {
    const fetchItems = async () => {
      try {
        setIsLoading(true);
        const response = await api.listItems({ limit: 10 });
        setItems(response.items);
        setNextCursor(response.nextCursor);
      } catch (err) {
        setError(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [api]);

  // Función para cargar más ítems
  const loadMore = async () => {
    if (!nextCursor) return;

    try {
      setIsFetchingMore(true);
      const response = await api.listItems({
        limit: 10,
        cursor: nextCursor
      });

      setItems(prevItems => [...prevItems, ...response.items]);
      setNextCursor(response.nextCursor);
    } catch (err) {
      setError(err);
    } finally {
      setIsFetchingMore(false);
    }
  };

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <ErrorMessage message={error.message} />;
  }

  return (
    <div>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>

      <button
        onClick={loadMore}
        disabled={!nextCursor || isFetchingMore}
      >
        {isFetchingMore
          ? 'Cargando más...'
          : nextCursor
          ? 'Cargar más'
          : 'No hay más ítems'}
      </button>
    </div>
  );
}
```
</Drawer>

### Manejo de errores

La integración incluye manejo de errores incorporado con respuestas de error tipadas. Se genera un tipo `<operation-name>Error` que encapsula las posibles respuestas de error definidas en la especificación OpenAPI. Cada error tiene una propiedad `status` y `error`, y al verificar el valor de `status` puedes determinar el tipo específico de error.

```tsx {12}
import { useMutation } from '@tanstack/react-query';

function MyComponent() {
  const api = useMyApi();
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleClick = () => {
    createItem.mutate({ name: 'New Item' });
  };

  if (createItem.error) {
    switch (createItem.error.status) {
      case 400:
        // error.error está tipado como CreateItem400Response
        return (
          <div>
            <h2>Entrada inválida:</h2>
            <p>{createItem.error.error.message}</p>
            <ul>
              {createItem.error.error.validationErrors.map((err) => (
                <li key={err.field}>{err.message}</li>
              ))}
            </ul>
          </div>
        );
      case 403:
        // error.error está tipado como CreateItem403Response
        return (
          <div>
            <h2>No autorizado:</h2>
            <p>{createItem.error.error.reason}</p>
          </div>
        );
      case 500:
      case 502:
        // error.error está tipado como CreateItem5XXResponse
        return (
          <div>
            <h2>Error del servidor:</h2>
            <p>{createItem.error.error.message}</p>
            <p>Trace ID: {createItem.error.error.traceId}</p>
          </div>
        );
    }
  }

  return <button onClick={handleClick}>Crear ítem</button>;
}
```

<Drawer title="Manejo de errores usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente vanilla directamente.">
```tsx {9,15}
function MyComponent() {
  const api = useMyApiClient();
  const [error, setError] = useState<CreateItemError | null>(null);

  const handleClick = async () => {
    try {
      await api.createItem({ name: 'New Item' });
    } catch (e) {
      const err = e as CreateItemError;
      setError(err);
    }
  };

  if (error) {
    switch (error.status) {
      case 400:
        // error.error está tipado como CreateItem400Response
        return (
          <div>
            <h2>Entrada inválida:</h2>
            <p>{error.error.message}</p>
            <ul>
              {error.error.validationErrors.map((err) => (
                <li key={err.field}>{err.message}</li>
              ))}
            </ul>
          </div>
        );
      case 403:
        // error.error está tipado como CreateItem403Response
        return (
          <div>
            <h2>No autorizado:</h2>
            <p>{error.error.reason}</p>
          </div>
        );
      case 500:
      case 502:
        // error.error está tipado como CreateItem5XXResponse
        return (
          <div>
            <h2>Error del servidor:</h2>
            <p>{error.error.message}</p>
            <p>Trace ID: {error.error.traceId}</p>
          </div>
        );
    }
  }

  return <button onClick={handleClick}>Crear ítem</button>;
}
```
</Drawer>

### Consumir un stream

Si has <Link path="guides/fastapi#streaming">configurado tu FastAPI para transmitir respuestas</Link>, tu hook `useQuery` se actualizará automáticamente con nuevos datos a medida que lleguen fragmentos del stream.

Por ejemplo:

```tsx {3}
function MyStreamingComponent() {
  const api = useMyApi();
  const stream = useQuery(api.myStream.queryOptions());

  return (
    <ul>
      {(stream.data ?? []).map((chunk) => (
        <li>
          {chunk.timestamp.toISOString()}: {chunk.message}
        </li>
      ))}
    </ul>
  );
}
```

Puedes usar las propiedades `isLoading` y `fetchStatus` para determinar el estado actual del stream si es necesario. Un stream sigue este ciclo de vida:

<Steps>
  1. Se envía la petición HTTP para iniciar el stream

      - `isLoading` es `true`
      - `fetchStatus` es `'fetching'`
      - `data` es `undefined`

  2. Se recibe el primer fragmento del stream

      - `isLoading` pasa a `false`
      - `fetchStatus` sigue siendo `'fetching'`
      - `data` se convierte en un array con el primer fragmento

  3. Se reciben fragmentos subsiguientes

      - `isLoading` sigue siendo `false`
      - `fetchStatus` sigue siendo `'fetching'`
      - `data` se actualiza con cada nuevo fragmento recibido

  4. El stream finaliza

      - `isLoading` sigue siendo `false`
      - `fetchStatus` pasa a `'idle'`
      - `data` es un array con todos los fragmentos recibidos
</Steps>

<Drawer title="Streaming usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente vanilla directamente.">

Si has <Link path="guides/fastapi#streaming">configurado tu FastAPI para transmitir respuestas</Link>, el cliente generado incluirá métodos tipados para iterar asincrónicamente sobre los fragmentos del stream usando sintaxis `for await`.

Por ejemplo:

```tsx {8}
function MyStreamingComponent() {
  const api = useMyApiClient();

  const [chunks, setChunks] = useState<Chunk[]>([]);

  useEffect(() => {
    const streamChunks = async () => {
      for await (const chunk of api.myStream()) {
        setChunks((prev) => [...prev, chunk]);
      }
    };
    streamChunks();
  }, [api]);

  return (
    <ul>
      {chunks.map((chunk) => (
        <li>
          {chunk.timestamp.toISOString()}: {chunk.message}
        </li>
      ))}
    </ul>
  );
}
```
</Drawer>

:::note
Si tienes una API de streaming que acepta un parámetro `cursor`, cuando uses el hook `useInfiniteQuery`, cada página esperará a que el stream finalice antes de considerarse cargada.
:::

## Personalizando el código generado

### Consultas y mutaciones

Por defecto, las operaciones en tu FastAPI que usan los métodos HTTP `PUT`, `POST`, `PATCH` y `DELETE` se consideran mutaciones, y las demás se consideran consultas.

Puedes cambiar este comportamiento usando `x-query` y `x-mutation`.

#### x-query

```python
@app.post(
    "/items",
    openapi_extra={
        "x-query": True
    }
)
def list_items():
    # ...
```

El hook generado proveerá `queryOptions` aunque use el método HTTP `POST`:

```tsx
const items = useQuery(api.listItems.queryOptions());
```

#### x-mutation

```python
@app.get(
    "/start-processing",
    openapi_extra={
        "x-mutation": True
    }
)
def start_processing():
    # ...
```

El hook generado proveerá `mutationOptions` aunque use el método HTTP `GET`:

```tsx
// El hook generado incluirá las opciones personalizadas
const startProcessing = useMutation(api.startProcessing.mutationOptions());
```

### Cursor de paginación personalizado

Por defecto, los hooks generados asumen paginación basada en cursor con un parámetro llamado `cursor`. Puedes personalizar esto usando la extensión `x-cursor`:

```python
@app.get(
    "/items",
    openapi_extra={
        # Especifica un nombre diferente para el parámetro del cursor
        "x-cursor": "page_token"
    }
)
def list_items(page_token: str = None, limit: int = 10):
    # ...
    return {
        "items": items,
        "page_token": next_page_token  # La respuesta debe incluir el cursor con el mismo nombre
    }
```

Si no quieres generar `infiniteQueryOptions` para una operación, puedes establecer `x-cursor` en `False`:

```python
@app.get(
    "/items",
    openapi_extra={
        # Deshabilita la paginación basada en cursor para este endpoint
        "x-cursor": False
    }
)
def list_items(page: int = 1, limit: int = 10):
    # ...
    return {
        "items": items,
        "total": total_count,
        "page": page,
        "pages": total_pages
    }
```

### Agrupación de operaciones

Los hooks y métodos del cliente generados se organizan automáticamente según los tags OpenAPI en tus endpoints FastAPI. Esto ayuda a mantener organizadas las llamadas API y facilita encontrar operaciones relacionadas.

Por ejemplo:

```python title="items.py"
@app.get(
    "/items",
    tags=["items"],
)
def list():
    # ...

@app.post(
    "/items",
    tags=["items"],
)
def create(item: Item):
    # ...
```

```python title="users.py"
@app.get(
    "/users",
    tags=["users"],
)
def list():
    # ...
```

Los hooks generados se agruparán según estos tags:

```tsx
import { useQuery, useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function ItemsAndUsers() {
  const api = useMyApi();

  // Las operaciones de Items se agrupan bajo api.items
  const items = useQuery(api.items.list.queryOptions());
  const createItem = useMutation(api.items.create.mutationOptions());

  // Las operaciones de Users se agrupan bajo api.users
  const users = useQuery(api.users.list.queryOptions());

  // Ejemplo de uso
  const handleCreateItem = () => {
    createItem.mutate({ name: 'New Item' });
  };

  return (
    <div>
      <h2>Ítems</h2>
      <ul>
        {items.data?.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <button onClick={handleCreateItem}>Añadir ítem</button>

      <h2>Usuarios</h2>
      <ul>
        {users.data?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

Esta agrupación facilita organizar tus llamadas API y provee mejor autocompletado en tu IDE.

<Drawer title="Operaciones agrupadas usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function ItemsAndUsers() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // Cargar datos
  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsLoading(true);

        // Operaciones de Items agrupadas bajo api.items
        const itemsData = await api.items.list();
        setItems(itemsData);

        // Operaciones de Users agrupadas bajo api.users
        const usersData = await api.users.list();
        setUsers(usersData);
      } catch (error) {
        console.error('Error obteniendo datos:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [api]);

  const handleCreateItem = async () => {
    try {
      // Crear ítem usando el método agrupado
      const newItem = await api.items.create({ name: 'New Item' });
      setItems(prevItems => [...prevItems, newItem]);
    } catch (error) {
      console.error('Error creando ítem:', error);
    }
  };

  if (isLoading) {
    return <div>Cargando...</div>;
  }

  return (
    <div>
      <h2>Ítems</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <button onClick={handleCreateItem}>Añadir ítem</button>

      <h2>Usuarios</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```
</Drawer>

:::tip
También puedes dividir tu API usando múltiples `routers`. Consulta la [Documentación de FastAPI](https://fastapi.tiangolo.com/tutorial/bigger-applications/) para más detalles.
:::

### Errores

Puedes personalizar las respuestas de error en tu FastAPI definiendo clases de excepción personalizadas, manejadores de excepción y especificando modelos de respuesta para diferentes códigos de estado. El cliente generado manejará automáticamente estos tipos de error personalizados.

#### Definir modelos de error personalizados

Primero, define tus modelos de error usando Pydantic:

```python title="models.py"
from pydantic import BaseModel

class ErrorDetails(BaseModel):
    message: str

class ValidationError(BaseModel):
    message: str
    field_errors: list[str]
```

#### Crear excepciones personalizadas

Luego crea clases de excepción para diferentes escenarios:

```python title="exceptions.py"
class NotFoundException(Exception):
    def __init__(self, message: str):
        self.message = message

class ValidationException(Exception):
    def __init__(self, details: ValidationError):
        self.details = details
```

#### Añadir manejadores de excepción

Registra manejadores de excepción para convertir tus excepciones en respuestas HTTP:

```python title="main.py"
from fastapi import Request
from fastapi.responses import JSONResponse

@app.exception_handler(NotFoundException)
async def not_found_handler(request: Request, exc: NotFoundException):
    return JSONResponse(
        status_code=404,
        content=exc.message,
    )

@app.exception_handler(ValidationException)
async def validation_error_handler(request: Request, exc: ValidationException):
    return JSONResponse(
        status_code=400,
        content=exc.details.model_dump(),
    )
```

:::tip
`JSONResponse` acepta un diccionario, así que usamos el método `model_dump` de nuestro modelo Pydantic.
:::

#### Especificar modelos de respuesta

Finalmente, especifica los modelos de respuesta para diferentes códigos de estado en tus endpoints:

```python title="main.py"
@app.get(
    "/items/{item_id}",
    responses={
        404: {"model": str}
        500: {"model": ErrorDetails}
    }
)
def get_item(item_id: str) -> Item:
    item = find_item(item_id)
    if not item:
        raise NotFoundException(message=f"Item con ID {item_id} no encontrado")
    return item

@app.post(
    "/items",
    responses={
        400: {"model": ValidationError},
        403: {"model": str}
    }
)
def create_item(item: Item) -> Item:
    if not is_valid(item):
        raise ValidationException(
            ValidationError(
                message="Datos de ítem inválidos",
                field_errors=["name es requerido"]
            )
        )
    return save_item(item)
```

#### Usar tipos de error personalizados en React

El cliente generado manejará automáticamente estos tipos de error personalizados, permitiéndote tipar y manejar diferentes respuestas de error:

```tsx
import { useMutation, useQuery } from '@tanstack/react-query';

function ItemComponent() {
  const api = useMyApi();

  // Consulta con manejo de errores tipado
  const getItem = useQuery({
    ...api.getItem.queryOptions({ itemId: '123' }),
    onError: (error) => {
      // El error está tipado según las respuestas en tu FastAPI
      switch (error.status) {
        case 404:
          // error.error es un string como se especificó en las respuestas
          console.error('No encontrado:', error.error);
          break;
        case 500:
          // error.error está tipado como ErrorDetails
          console.error('Error del servidor:', error.error.message);
          break;
      }
    }
  });

  // Mutación con manejo de errores tipado
  const createItem = useMutation({
    ...api.createItem.mutationOptions(),
    onError: (error) => {
      switch (error.status) {
        case 400:
          // error.error está tipado como ValidationError
          console.error('Error de validación:', error.error.message);
          console.error('Errores de campo:', error.error.field_errors);
          break;
        case 403:
          // error.error es un string como se especificó en las respuestas
          console.error('Prohibido:', error.error);
          break;
      }
    }
  });

  // Renderizado del componente con manejo de errores
  if (getItem.isError) {
    if (getItem.error.status === 404) {
      return <NotFoundMessage message={getItem.error.error} />;
    } else {
      return <ErrorMessage message={getItem.error.error.message} />;
    }
  }

  return (
    <div>
      {/* Contenido del componente */}
    </div>
  );
}
```

<Drawer title="Manejar errores personalizados con el cliente directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
import { useState, useEffect } from 'react';

function ItemComponent() {
  const api = useMyApiClient();
  const [item, setItem] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);

  // Obtener ítem con manejo de errores
  useEffect(() => {
    const fetchItem = async () => {
      try {
        setLoading(true);
        const data = await api.getItem({ itemId: '123' });
        setItem(data);
      } catch (e) {
        // El error está tipado según las respuestas en tu FastAPI
        const err = e as GetItemError;
        setError(err);

        switch (err.status) {
          case 404:
            // err.error es un string como se especificó en las respuestas
            console.error('No encontrado:', err.error);
            break;
          case 500:
            // err.error está tipado como ErrorDetails
            console.error('Error del servidor:', err.error.message);
            break;
        }
      } finally {
        setLoading(false);
      }
    };

    fetchItem();
  }, [api]);

  // Crear ítem con manejo de errores
  const handleCreateItem = async (data) => {
    try {
      await api.createItem(data);
    } catch (e) {
      const err = e as CreateItemError;

      switch (err.status) {
        case 400:
          // err.error está tipado como ValidationError
          console.error('Error de validación:', err.error.message);
          console.error('Errores de campo:', err.error.field_errors);
          break;
        case 403:
          // err.error es un string como se especificó en las respuestas
          console.error('Prohibido:', err.error);
          break;
      }
    }
  };

  // Renderizado del componente con manejo de errores
  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    if (error.status === 404) {
      return <NotFoundMessage message={error.error} />;
    } else if (error.status === 500) {
      return <ErrorMessage message={error.error.message} />;
    }
  }

  return (
    <div>
      {/* Contenido del componente */}
    </div>
  );
}
```
</Drawer>

:::tip
Al definir respuestas de error en FastAPI, siempre usa el parámetro `responses` para especificar el modelo de cada código de estado. Esto asegura que el cliente generado tendrá información de tipos adecuada para el manejo de errores.
:::

## Mejores prácticas

### Manejar estados de carga

Siempre maneja los estados de carga y error para una mejor experiencia de usuario:

```tsx
import { useQuery } from '@tanstack/react-query';

function ItemList() {
  const api = useMyApi();
  const items = useQuery(api.listItems.queryOptions());

  if (items.isLoading) {
    return <LoadingSpinner />;
  }

  if (items.isError) {
    const err = items.error;
    switch (err.status) {
      case 403:
        // err.error está tipado como ListItems403Response
        return <ErrorMessage message={err.error.reason} />;
      case 500:
      case 502:
        // err.error está tipado como ListItems5XXResponse
        return (
          <ErrorMessage
            message={err.error.message}
            details={`Trace ID: ${err.error.traceId}`}
          />
        );
      default:
        return <ErrorMessage message="Error desconocido" />;
    }
  }

  return (
    <ul>
      {items.data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

<Drawer title="Manejar estados de carga usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente vanilla directamente.">
```tsx
function ItemList() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchItems = async () => {
      try {
        const data = await api.listItems();
        setItems(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchItems();
  }, [api]);

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    const err = error as ListItemsError;
    switch (err.status) {
      case 403:
        // err.error está tipado como ListItems403Response
        return <ErrorMessage message={err.error.reason} />;
      case 500:
      case 502:
        // err.error está tipado como ListItems5XXResponse
        return (
          <ErrorMessage
            message={err.error.message}
            details={`Trace ID: ${err.error.traceId}`}
          />
        );
      default:
        return <ErrorMessage message="Error desconocido" />;
    }
  }

  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```
</Drawer>

### Actualizaciones optimistas

Implementa actualizaciones optimistas para una mejor experiencia de usuario:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function ItemList() {
  const api = useMyApi();
  const queryClient = useQueryClient();

  // Consulta para obtener ítems
  const itemsQuery = useQuery(api.listItems.queryOptions());

  // Mutación para eliminar ítems con actualizaciones optimistas
  const deleteMutation = useMutation({
    ...api.deleteItem.mutationOptions(),
    onMutate: async (itemId) => {
      // Cancelar cualquier recarga pendiente
      await queryClient.cancelQueries({ queryKey: api.listItems.queryKey() });

      // Tomar instantánea del valor previo
      const previousItems = queryClient.getQueryData(api.listItems.queryKey());

      // Actualizar optimistamente al nuevo valor
      queryClient.setQueryData(
        api.listItems.queryKey(),
        (old) => old.filter((item) => item.id !== itemId)
      );

      // Retornar un objeto de contexto con la instantánea
      return { previousItems };
    },
    onError: (err, itemId, context) => {
      // Si la mutación falla, usa el contexto para revertir
      queryClient.setQueryData(api.listItems.queryKey(), context.previousItems);
      console.error('Error eliminando ítem:', err);
    },
    onSettled: () => {
      // Siempre recargar después de error o éxito para sincronizar datos
      queryClient.invalidateQueries({ queryKey: api.listItems.queryKey() });
    },
  });

  if (itemsQuery.isLoading) {
    return <LoadingSpinner />;
  }

  if (itemsQuery.isError) {
    return <ErrorMessage message="Error cargando ítems" />;
  }

  return (
    <ul>
      {itemsQuery.data.map((item) => (
        <li key={item.id}>
          {item.name}
          <button
            onClick={() => deleteMutation.mutate(item.id)}
            disabled={deleteMutation.isPending}
          >
            {deleteMutation.isPending ? 'Eliminando...' : 'Eliminar'}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

<Drawer title="Actualizaciones optimistas usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
function ItemList() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);

  const handleDelete = async (itemId) => {
    // Eliminar optimistamente el ítem
    const previousItems = items;
    setItems(items.filter((item) => item.id !== itemId));

    try {
      await api.deleteItem(itemId);
    } catch (error) {
      // Restaurar ítems previos en caso de error
      setItems(previousItems);
      console.error('Error eliminando ítem:', error);
    }
  };

  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => handleDelete(item.id)}>Eliminar</button>
        </li>
      ))}
    </ul>
  );
}
```
</Drawer>

## Seguridad de tipos

La integración provee seguridad de tipos de extremo a extremo. Tu IDE proveerá autocompletado y verificación de tipos para todas tus llamadas API:

```tsx
import { useMutation } from '@tanstack/react-query';

function ItemForm() {
  const api = useMyApi();

  // Mutación tipada para crear ítems
  const createItem = useMutation({
    ...api.createItem.mutationOptions(),
    // ✅ Error de tipo si el callback onSuccess no maneja el tipo de respuesta correcto
    onSuccess: (data) => {
      // data está completamente tipado según el schema de respuesta de tu API
      console.log(`Ítem creado con ID: ${data.id}`);
    },
  });

  const handleSubmit = (data: CreateItemInput) => {
    // ✅ Error de tipo si la entrada no coincide con el schema
    createItem.mutate(data);
  };

  // La UI de errores puede usar narrowing de tipos para manejar diferentes errores
  if (createItem.error) {
    const error = createItem.error;
    switch (error.status) {
      case 400:
        // error.error está tipado como CreateItem400Response
        return (
          <FormError
            message="Entrada inválida"
            errors={error.error.validationErrors}
          />
        );
      case 403:
        // error.error está tipado como CreateItem403Response
        return <AuthError reason={error.error.reason} />;
      default:
        // error.error está tipado como CreateItem5XXResponse para 500, 502, etc.
        return <ServerError message={error.error.message} />;
    }
  }

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit({ name: 'New Item' });
    }}>
      {/* Campos del formulario */}
      <button
        type="submit"
        disabled={createItem.isPending}
      >
        {createItem.isPending ? 'Creando...' : 'Crear ítem'}
      </button>
    </form>
  );
}
```

<Drawer title="Seguridad de tipos usando el cliente de API directamente" trigger="Haz clic aquí para ver un ejemplo usando el cliente directamente.">
```tsx
function ItemForm() {
  const api = useMyApiClient();
  const [error, setError] = useState<CreateItemError | null>(null);

  const handleSubmit = async (data: CreateItemInput) => {
    try {
      // ✅ Error de tipo si la entrada no coincide con el schema
      await api.createItem(data);
    } catch (e) {
      // ✅ El tipo de error incluye todas las posibles respuestas de error
      const err = e as CreateItemError;
      switch (err.status) {
        case 400:
          // err.error está tipado como CreateItem400Response
          console.error('Errores de validación:', err.error.validationErrors);
          break;
        case 403:
          // err.error está tipado como CreateItem403Response
          console.error('No autorizado:', err.error.reason);
          break;
        case 500:
        case 502:
          // err.error está tipado como CreateItem5XXResponse
          console.error(
            'Error del servidor:',
            err.error.message,
            'Trace:',
            err.error.traceId,
          );
          break;
      }
      setError(err);
    }
  };

  // La UI de errores puede usar narrowing de tipos para manejar diferentes errores
  if (error) {
    switch (error.status) {
      case 400:
        return (
          <FormError
            message="Entrada inválida"
            errors={error.error.validationErrors}
          />
        );
      case 403:
        return <AuthError reason={error.error.reason} />;
      default:
        return <ServerError message={error.error.message} />;
    }
  }

  return <form onSubmit={handleSubmit}>{/* ... */}</form>;
}
```
</Drawer>

Los tipos se generan automáticamente del schema OpenAPI de tu FastAPI, asegurando que cualquier cambio en tu API se refleje en tu código frontend después de un build.