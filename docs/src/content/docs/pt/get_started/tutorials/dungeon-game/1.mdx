---
title: "Jogo de Dungeons com IA"
description: "Um guia passo a passo de como construir um jogo de aventura de dungeon com IA usando o @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## M√≥dulo 1: Configura√ß√£o do monorepo

Vamos come√ßar criando um novo monorepo. A partir do diret√≥rio desejado, execute o seguinte comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Isso configurar√° um monorepo NX dentro do diret√≥rio `dungeon-adventure` que voc√™ poder√° abrir no vscode. Deve parecer com o seguinte:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqui √© onde seus subprojetos residir√£o
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura o CLI do NX e padr√µes do monorepo
- package.json todas as depend√™ncias do node s√£o definidas aqui
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json dependendo do gerenciador de pacotes
- pnpm-workspace.yaml se usar pnpm
- README.md
- tsconfig.base.json todos os subprojetos baseados em node estendem este
- tsconfig.json
</FileTree>

Para come√ßar a adicionar componentes do `@aws/nx-plugin` ao monorepo, precisamos instal√°-lo como uma depend√™ncia de desenvolvimento executando o seguinte comando da raiz do monorepo `dungeon-adventure`:

<InstallCommand dev pkg="@aws/nx-plugin" />

Agora estamos prontos para come√ßar a criar nossos diferentes subprojetos usando o `@aws/nx-plugin`.

<Aside type="tip">√â uma pr√°tica recomendada garantir que todos os arquivos n√£o stageados sejam commitados no Git antes de executar qualquer generator. Isso permite ver o que mudou ap√≥s executar o generator via `git diff`</Aside>

### Game API

Primeiro vamos criar nossa Game API. Para isso, vamos criar uma API tRPC chamada `GameApi` seguindo os passos abaixo:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Voc√™ deve ver alguns novos arquivos aparecerem na sua √°rvore de arquivos.

<Aside>
O `package.json` raiz agora est√° configurado com `type` como `module`, o que significa que ESM √© o tipo de m√≥dulo padr√£o para todos os subprojetos baseados em node fornecidos pelo `@aws/nx-plugin`. Para mais detalhes sobre projetos TypeScript, consulte o <Link path="guides/typescript-project">guia ts#project</Link>.
</Aside>

<Drawer title="Arquivos atualizados do ts#trpc-api" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados pelo generator `ts#trpc-api`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos da aplica√ß√£o
          - http-apis/
            - **game-api.ts** construct CDK para criar sua API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen√©ricos
          - http-api.ts construct CDK base para uma API HTTP
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartilhados
      - src/
        - index.ts
        - runtime-config.ts defini√ß√£o de interface usada pelo CDK e website
      - project.json
      - ...
  - game-api/
    - backend/ c√≥digo de implementa√ß√£o tRPC
      - src/
        - client/ cliente vanilla usado para chamadas m√°quina a m√°quina
          - index.ts
          - sigv4.ts
        - middleware/ instrumenta√ß√£o com powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementa√ß√µes espec√≠ficas para os procedimentos/rotas da API
          - **echo.ts**
        - index.ts
        - init.ts configura contexto e middleware
        - local-server.ts usado ao executar o servidor tRPC localmente
        - **router.ts** ponto de entrada para o lambda handler que define todos os procedimentos
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Analisando alguns dos arquivos-chave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
O roteador define o ponto de entrada para sua API tRPC e √© onde voc√™ declarar√° todos os m√©todos da API. Como visto acima, temos um m√©todo chamado `echo` com sua implementa√ß√£o no arquivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este arquivo √© a implementa√ß√£o do m√©todo `echo` e como visto √© fortemente tipado declarando suas estruturas de dados de entrada e sa√≠da. Ele importa essas defini√ß√µes do projeto `:dungeon-adventure/game-api-schema` que √© um [alias](https://www.typescriptlang.org/tsconfig/paths.html) para o projeto de schema.

<Aside type="tip">Se voc√™ est√° vendo um erro de importa√ß√£o em sua IDE, √© porque nosso backend ainda n√£o tem uma refer√™ncia TypeScript configurada em seu tsconfig.json. O Nx foi [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para criar essas refer√™ncias *dinamicamente* sempre que um build/compile √© executado ou se voc√™ executar o comando `nx sync` manualmente. Para mais informa√ß√µes, consulte o <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guia TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas as defini√ß√µes de schema tRPC s√£o feitas usando [Zod](https://zod.dev/) e exportadas como tipos TypeScript via sintaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/http-apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este √© o construct CDK que define nossa GameApi. Como visto, ele j√° configurou o caminho do handler para o bundle gerado de nossa implementa√ß√£o backend tRPC. Isso significa que no momento do `cdk synth`, o bundling n√£o ocorre (diferente de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)), pois j√° fizemos o bundling como parte do target de build do projeto backend.

</Drawer>

### Story API

Agora vamos criar nossa Story API. Para isso, vamos criar uma API Fast chamada `StoryApi` seguindo os passos abaixo:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Voc√™ deve ver alguns novos arquivos aparecerem na sua √°rvore de arquivos.
<Drawer title="Arquivos atualizados do py#fast-api" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados pelo generator `py#fast-api`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- .venv/ ambiente virtual √∫nico para o monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos da aplica√ß√£o
          - http-apis/
            - **story-api.ts** construct CDK para criar sua Fast API
            - index.ts atualizado para exportar a nova story-api
      - project.json atualizado para adicionar depend√™ncia de build no story_api
    - types/ tipos compartilhados
      - src/
        - **runtime-config.ts** atualizado para adicionar a StoryApi
  - story_api/
    - story_api/ m√≥dulo python
      - init.py configura powertools, FastAPI e middleware
      - **main.py** ponto de entrada para o lambda contendo todas as rotas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version vers√£o do python fixada pelo uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este √© o construct CDK que define nossa StoryApi. Como visto, ele j√° configurou o caminho do handler para o bundle gerado de nossa implementa√ß√£o backend Fast API. Isso significa que no momento do `cdk synth`, o bundling n√£o ocorre (diferente de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)), pois j√° fizemos o bundling como parte do target de build do projeto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aqui est√° um exemplo do generator realizando uma transforma√ß√£o AST que preserva todo o c√≥digo existente e realiza uma atualiza√ß√£o. Veja que a `StoryApi` foi adicionada √† defini√ß√£o `IRuntimeConfig`, o que significa que quando isso for consumido pelo frontend, ir√° impor type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Este √© onde todos os m√©todos da API ser√£o definidos. Como visto aqui, temos um m√©todo `read_root` mapeado para a rota `GET /`. Voc√™ pode usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar entradas e sa√≠das dos m√©todos e garantir type safety.

</Drawer>

### Game UI: Website

Agora vamos criar a UI que permitir√° interagir com o jogo. Para isso, vamos criar um website chamado `GameUI` seguindo os passos abaixo:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Voc√™ deve ver alguns novos arquivos aparecerem na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#cloudscape-website" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados pelo generator `ts#cloudscape-website`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos da aplica√ß√£o
          - static-websites/
            - **game-ui.ts** construct CDK para criar sua Game UI
        - core/
          - static-website.ts construct gen√©rico de website est√°tico
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout geral da p√°gina: cabe√ßalho, rodap√©, sidebar, etc
          - navitems.ts itens de navega√ß√£o da sidebar
      - hooks/
        - useAppLayout.tsx permite definir dinamicamente notifica√ß√µes, estilo da p√°gina, etc
      - routes/ rotas baseadas em arquivo do @tanstack/react-router
        - index.tsx p√°gina raiz '/' redireciona para '/welcome'
        - __root.tsx todos os p√°ginas usam este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** ponto de entrada do React
        - routeTree.gen.ts atualizado automaticamente pelo @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este √© o construct CDK que define nossa GameUI. Como visto, ele j√° configurou o caminho para o bundle gerado de nossa UI baseada em Vite. Isso significa que no momento do `build`, o bundling ocorre dentro do target de build do projeto game-ui e sua sa√≠da √© usada aqui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra a inst√¢ncia do router para type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este √© o ponto de entrada onde o React √© montado. Como mostrado, ele inicialmente configura um `@tanstack/react-router` em uma configura√ß√£o de [`roteamento baseado em arquivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Isso significa que, enquanto seu servidor de desenvolvimento estiver rodando, voc√™ pode simplesmente criar arquivos na pasta `routes` e o `@tanstack/react-router` criar√° a configura√ß√£o boilerplate para voc√™, atualizando o arquivo `routeTree.gen.ts`. Este arquivo mant√©m todas as rotas de forma type-safe, o que significa que ao usar `<Link>`, a op√ß√£o `to` s√≥ mostrar√° rotas v√°lidas. Para mais informa√ß√µes, consulte a [documenta√ß√£o do `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Um componente que ser√° renderizado ao navegar para a rota `/welcome`. O `@tanstack/react-router` gerenciar√° a `Route` para voc√™ sempre que criar/mover este arquivo (desde que o servidor de desenvolvimento esteja rodando). Isso ser√° mostrado em uma se√ß√£o posterior deste tutorial.

</Drawer>

### Game UI: Auth

Agora vamos configurar nossa Game UI para exigir acesso autenticado via Amazon Cognito seguindo os passos abaixo:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Voc√™ deve ver alguns arquivos novos/alterados em sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#cloudscape-website#auth" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados/atualizados pelo generator `ts#cloudscape-website#auth`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para criar pools de usu√°rios/identidade
    - types/
      - src/
        - runtime-config.ts atualizado para adicionar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adiciona o usu√°rio logado/logout ao cabe√ßalho
        - CognitoAuth/
          - index.ts gerencia login no Cognito
        - RuntimeConfig/
          - index.tsx busca o `runtime-config.json` e fornece aos filhos via contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Atualizado para adicionar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra a inst√¢ncia do router para type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Os componentes `RuntimeConfigProvider` e `CognitoAuth` foram adicionados ao arquivo `main.tsx` via transforma√ß√£o AST. Isso permite que o componente `CognitoAuth` autentique com o Amazon Cognito buscando o `runtime-config.json` que cont√©m a configura√ß√£o de conex√£o Cognito necess√°ria para fazer chamadas backend ao destino correto.

</Drawer>

### Game UI: Conectar √† Story API

Agora vamos configurar nossa Game UI para se conectar √† Story API criada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Voc√™ deve ver alguns arquivos novos/alterados em sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados da conex√£o UI -> FastAPI" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados/atualizados pelo generator `api-connection`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado pela StoryApi para assinar requests
        - useStoryApiClient.tsx hook para construir um cliente StoryApi
        - useStoryApi.tsx hook para interagir com a StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx provedor do cliente TanStack Query
        - StoryApiProvider.tsx Provedor para o hook TanStack Query da StoryApi
      - main.tsx Instrumenta o QueryClientProvider e StoryApiProvider
    - .gitignore ignora arquivos de cliente gerados
    - project.json atualizado para adicionar targets para gerar hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json atualizado para emitir um arquivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Este hook pode ser usado para fazer requests autenticados √† `StoryApi`. Como visto na implementa√ß√£o, ele usa o `StoryApi` que √© gerado no momento do build e, portanto, voc√™ ver√° um erro em sua IDE at√© construirmos nosso c√≥digo. Para mais detalhes sobre como o cliente √© gerado ou como consumir a API, consulte o <Link path="guides/api-connection/react-fastapi">guia React para FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

O componente provedor acima usa o hook `useStoryApiClient` e instancia o `StoryApiOptionsProxy`, que √© usado para construir op√ß√µes para os hooks TanStack Query. Voc√™ pode usar o hook correspondente `useStoryApi` para acessar este proxy de op√ß√µes, que fornece uma maneira de interagir com sua FastAPI de forma consistente com sua API tRPC.

Como `useStoryApiClient` nos fornece um iterador ass√≠ncrono para nossa API de streaming, usaremos apenas o cliente vanilla diretamente neste tutorial.

<Aside type="caution">
Os arquivos `src/generated/story-api/*.gen.ts` nunca devem ser modificados manualmente, pois ser√£o re-gerados toda vez que voc√™ construir sua API.
</Aside>

</Drawer>

### Game UI: Conectar √† Game API

Agora vamos configurar nossa Game UI para se conectar √† Game API criada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Voc√™ deve ver alguns arquivos novos/alterados em sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados da conex√£o UI -> tRPC" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados/atualizados pelo generator `api-connection`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx todas as APIs tRPC configuradas
          - TrpcClientProviders.tsx cria um provedor de cliente por API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hooks para chamar a GameApi
      - **main.tsx** injeta os provedores de clientes trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Este hook usa a [integra√ß√£o mais recente do React Query do tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client), permitindo que usu√°rios interajam com `@tanstack/react-query` diretamente sem camadas adicionais de abstra√ß√£o. Para exemplos de como chamar APIs tRPC, consulte o <Link path="guides/api-connection/react-trpc#using-the-generated-code">guia de uso do hook tRPC</Link>.

<Aside>
O hook `useGameApi` √© diferente do `useStoryApi` porque n√£o requer um build para que as altera√ß√µes sejam refletidas, gra√ßas ao uso de [infer√™ncia TypeScript](https://trpc.io/docs/concepts) pelo tRPC. Isso permite que desenvolvedores fa√ßam altera√ß√µes no backend que s√£o refletidas instantaneamente no frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra a inst√¢ncia do router para type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

O arquivo `main.tsx` foi atualizado via transforma√ß√£o AST para injetar os provedores tRPC.

</Drawer>

### Game UI: Infraestrutura

Agora o √∫ltimo subprojeto que precisamos criar √© para a infraestrutura CDK. Para cri√°-lo, siga os passos abaixo:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Voc√™ deve ver alguns arquivos novos/alterados em sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#infra" trigger="Clique aqui para examinar esses arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados/atualizados pelo generator `ts#infra`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqui
      - index.ts
      - **main.ts** ponto de entrada que define todas as stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json adiciona refer√™ncias
  - tsconfig.base.json adiciona alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Use isto para implantar seu pr√≥prio ambiente sandbox (assume suas credenciais CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Este √© o ponto de entrada para sua aplica√ß√£o CDK.

Ele est√° configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para executar valida√ß√£o de infraestrutura baseada no conjunto de regras configurado. Isso √© instrumentado p√≥s-s√≠ntese.

<Aside type="tip">
Pode haver casos onde voc√™ quer suprimir certas regras em recursos. Voc√™ pode fazer isso de duas formas:

###### Suprimir uma regra em um construct espec√≠fico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime a RULE_NAME para o construct dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir uma regra em um construct descendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime a RULE_NAME para o construct ou qualquer descendente se for uma inst√¢ncia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // O c√≥digo que define sua stack vai aqui
  }
}
```

Este √© onde instanciaremos nossos constructs CDK para construir nosso jogo dungeon adventure.

</Drawer>

#### Atualizar nossa infraestrutura

Vamos atualizar nosso `packages/infra/src/stacks/application-stack.ts` para instanciar alguns de nossos constructs j√° gerados:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // O c√≥digo que define sua stack vai aqui
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // concede √† nossa fun√ß√£o autenticada acesso para invocar nossas APIs
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Garante que isto seja instanciado por √∫ltimo para que nosso runtime-config.json possa ser configurado automaticamente
+    new GameUI(this, 'GameUI');
  }
}

```

### Construindo nosso c√≥digo

<Drawer title="Comandos Nx" trigger="Agora √© hora de construir nosso c√≥digo pela primeira vez">
###### Targets √∫nicos vs m√∫ltiplos

O comando `run-many` executar√° um target em m√∫ltiplos subprojetos listados (`--all` os alvo todos). Ele garantir√° que depend√™ncias sejam executadas na ordem correta.

Voc√™ tamb√©m pode disparar um build (ou qualquer outra tarefa) para um target de projeto √∫nico executando o target diretamente no projeto. Por exemplo, se quisermos construir o projeto `@dungeon-adventure/infra`, voc√™ pode executar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando suas depend√™ncias

Voc√™ tamb√©m pode visualizar suas depend√™ncias via:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

O Nx depende de [cache](https://nx.dev/concepts/how-caching-works) para reutilizar artefatos de builds anteriores e acelerar o desenvolvimento. √â necess√°ria alguma configura√ß√£o para que isso funcione corretamente e pode haver casos onde voc√™ queira executar um build **sem usar o cache**. Para isso, basta adicionar o argumento `--skip-nx-cache` ao seu comando. Por exemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se por algum motivo voc√™ quiser limpar seu cache (armazenado na pasta `.nx`), execute:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Voc√™ deve ser questionado com o seguinte:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Esta mensagem indica que o NX detectou alguns arquivos que podem ser atualizados automaticamente. Neste caso, refere-se aos arquivos `tsconfig.json` que n√£o t√™m refer√™ncias TypeScript configuradas para projetos dependentes. Selecione a op√ß√£o **Yes, sync the changes and run the tasks** para prosseguir. Voc√™ deve notar que todos os erros de importa√ß√£o relacionados √† sua IDE s√£o resolvidos automaticamente, pois o generator sync adicionar√° as refer√™ncias TypeScript faltantes automaticamente!

<Aside type="tip">
Se encontrar erros de lint, voc√™ pode executar o seguinte comando para corrigi-los automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Falha de build no Windows">
<Drawer trigger="Se voc√™ estiver no Windows e encontrar um erro de build, clique aqui." title="Falha de build no Windows">
Se encontrar um erro de build/synth para o projeto `@dungeon-adventure/infra`, isso √© esperado pois a biblioteca que instrumenta o `cfn-guard` atualmente n√£o suporta Windows. H√° uma feature request acompanhando isso, mas por enquanto podemos simplesmente desabilitar o `cfn-guard` modificando o arquivo `packages/infra/src/main.ts` da seguinte forma:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Use isto para implantar seu pr√≥prio ambiente sandbox (assume suas credenciais CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos os artefatos constru√≠dos est√£o agora dispon√≠veis na pasta `dist/` na raiz do monorepo. Esta √© uma pr√°tica padr√£o ao usar projetos gerados pelo `@aws/nx-plugin`, pois n√£o polui sua √°rvore de arquivos com arquivos gerados. Caso queira limpar seus arquivos, voc√™ pode simplesmente deletar a pasta `dist/` sem se preocupar com arquivos gerados espalhados.

Parab√©ns! Voc√™ criou todos os subprojetos necess√°rios para come√ßar a implementar o n√∫cleo do nosso jogo Dunegeon Adventure.  üéâüéâüéâ