---
title: "Jogo de Dungeons com IA"
description: "Um guia passo a passo de como construir um jogo de aventura de dungeon alimentado por IA usando o @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## M√≥dulo 1: Configura√ß√£o do Monorepo

Vamos come√ßar criando um novo monorepo. Dentro do diret√≥rio desejado, execute o seguinte comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Isso configurar√° um monorepo NX dentro do diret√≥rio `dungeon-adventure` que voc√™ pode abrir no VSCode. Deve parecer com o seguinte:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqui ficar√£o seus subprojetos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura o CLI do NX e padr√µes do monorepo
- package.json todas as depend√™ncias Node s√£o definidas aqui
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json dependendo do gerenciador de pacotes
- pnpm-workspace.yaml se usar pnpm
- README.md
- tsconfig.base.json todos os subprojetos Node estendem este
- tsconfig.json
</FileTree>

Agora estamos prontos para come√ßar a criar nossos diferentes subprojetos usando o `@aws/nx-plugin`.

<Aside type="tip">√â uma boa pr√°tica garantir que todos os arquivos n√£o stageados estejam commitados no Git antes de executar qualquer gerador. Isso permite ver o que mudou ap√≥s executar o gerador via `git diff`</Aside>

### API do Jogo

Primeiro vamos criar nossa API do Jogo. Para isso, vamos criar uma API tRPC chamada `GameApi` seguindo os passos abaixo:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Voc√™ deve ver que alguns novos arquivos apareceram na sua √°rvore de arquivos.

<Aside>
O `package.json` raiz agora est√° configurado com `type` como `module`, o que significa que ESM √© o tipo de m√≥dulo padr√£o para todos os subprojetos Node fornecidos pelo `@aws/nx-plugin`. Para mais detalhes sobre projetos TypeScript, consulte o <Link path="guides/typescript-project">guia ts#project</Link>.
</Aside>

<Drawer title="Arquivos atualizados pelo ts#trpc-api" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados pelo gerador `ts#trpc-api`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos do app
          - apis/
            - **game-api.ts** construct CDK para criar sua API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen√©ricos
          - api/
            - rest-api.ts construct base para API Gateway Rest API
            - trpc-utils.ts utilit√°rios para constructs CDK de API tRPC
            - utils.ts utilit√°rios para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartilhados
      - src/
        - index.ts
        - runtime-config.ts defini√ß√£o de interface usada por CDK e website
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla usado para chamadas m√°quina-m√°quina em TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumenta√ß√£o com Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ defini√ß√µes de inputs e outputs da API
        - **echo.ts**
      - procedures/ implementa√ß√µes espec√≠ficas dos procedimentos/rotas da API
        - **echo.ts**
      - index.ts
      - init.ts configura contexto e middleware
      - local-server.ts usado ao executar o servidor tRPC localmente
      - **router.ts** ponto de entrada do lambda handler que define todos os procedimentos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Analisando alguns dos arquivos-chave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
O router define o ponto de entrada da sua API tRPC e √© onde voc√™ declara todos os m√©todos da API. Como visto acima, temos um m√©todo chamado `echo` com sua implementa√ß√£o no arquivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este arquivo √© a implementa√ß√£o do m√©todo `echo` e como visto √© fortemente tipado declarando suas estruturas de dados de entrada e sa√≠da.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas as defini√ß√µes de schema tRPC s√£o feitas usando [Zod](https://zod.dev/) e exportadas como tipos TypeScript via sintaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union de strings para todos os nomes de opera√ß√µes da API
type Operations = Procedures<AppRouter>;

/**
 * Propriedades para criar um construct GameApi
 *
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nomes de opera√ß√£o para integra√ß√µes do API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Um construct CDK que cria e configura uma API Gateway REST API da AWS
 * especificamente para GameApi.
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cria integra√ß√µes padr√£o para todas as opera√ß√µes, implementando cada opera√ß√£o como
   * sua pr√≥pria fun√ß√£o lambda individual.
   *
   * @param scope - O escopo do construct CDK
   * @returns Um IntegrationBuilder com integra√ß√µes lambda padr√£o
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aqui concedemos a qualquer credencial AWS da conta onde o projeto √© implantado para chamar a API.
          // Acesso refinado m√°quina-m√°quina pode ser definido aqui usando principals mais espec√≠ficos (ex: roles ou
          // usu√°rios) e recursos (ex: quais caminhos da API podem ser invocados por qual principal) se necess√°rio.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abre OPTIONS para permitir que navegadores fa√ßam requisi√ß√µes preflight n√£o autenticadas
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este √© o construct CDK que define nossa GameApi. Como visto, ele fornece um m√©todo `defaultIntegrations` que cria automaticamente uma fun√ß√£o lambda para cada procedimento em nossa API tRPC, apontando para a implementa√ß√£o da API empacotada. Isso significa que no momento do `cdk synth`, o empacotamento n√£o ocorre (diferente de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) pois j√° o empacotamos como parte do target de build do projeto backend.

</Drawer>

### API da Hist√≥ria

Agora vamos criar nossa API da Hist√≥ria. Para isso, vamos criar uma API Fast chamada `StoryApi` seguindo os passos abaixo:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Voc√™ deve ver que alguns novos arquivos apareceram na sua √°rvore de arquivos.
<Drawer title="Arquivos atualizados pelo py#fast-api" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados pelo gerador `py#fast-api`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- .venv/ √∫nico ambiente virtual para o monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos do app
          - apis/
            - **story-api.ts** construct CDK para criar sua Fast API
            - index.ts atualizado para exportar o novo story-api
      - project.json atualizado para adicionar depend√™ncia de build no story_api
    - types/ tipos compartilhados
      - src/
        - **runtime-config.ts** atualizado para adicionar o StoryApi
  - story_api/
    - story_api/ m√≥dulo Python
      - init.py configura Powertools, FastAPI e middleware
      - **main.py** ponto de entrada do lambda contendo todas as rotas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version vers√£o Python fixa do uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propriedades para criar um construct StoryApi
 *
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nomes de opera√ß√£o para integra√ß√µes do API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Um construct CDK que cria e configura uma API Gateway REST API da AWS
 * especificamente para StoryApi.
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cria integra√ß√µes padr√£o para todas as opera√ß√µes, implementando cada opera√ß√£o como
   * sua pr√≥pria fun√ß√£o lambda individual.
   *
   * @param scope - O escopo do construct CDK
   * @returns Um IntegrationBuilder com integra√ß√µes lambda padr√£o
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aqui concedemos a qualquer credencial AWS da conta onde o projeto √© implantado para chamar a API.
          // Acesso refinado m√°quina-m√°quina pode ser definido aqui usando principals mais espec√≠ficos (ex: roles ou
          // usu√°rios) e recursos (ex: quais caminhos da API podem ser invocados por qual principal) se necess√°rio.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abre OPTIONS para permitir que navegadores fa√ßam requisi√ß√µes preflight n√£o autenticadas
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Este √© o construct CDK que define nossa StoryApi. Como visto, ele fornece um m√©todo `defaultIntegrations` que cria automaticamente uma fun√ß√£o lambda para cada opera√ß√£o definida em nossa FastAPI, apontando para a implementa√ß√£o da API empacotada. Isso significa que no momento do `cdk synth`, o empacotamento n√£o ocorre (diferente de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) pois j√° o empacotamos como parte do target de build do projeto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aqui est√° um exemplo do gerador realizando uma transforma√ß√£o AST que preserva todo o c√≥digo existente e realiza uma atualiza√ß√£o. Veja que o `StoryApi` foi adicionado √† defini√ß√£o `IRuntimeConfig`, o que significa que quando isso for consumido pelo frontend, garantir√° seguran√ßa de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Este √© onde todos os m√©todos da sua API ser√£o definidos. Como visto aqui, temos um m√©todo `read_root` mapeado para a rota `GET /`. Voc√™ pode usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar inputs e outputs dos m√©todos e garantir seguran√ßa de tipos.

</Drawer>

### UI do Jogo: Website

Agora vamos criar a UI que permitir√° interagir com o jogo. Para isso, vamos criar um website chamado `GameUI` seguindo os passos abaixo:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Voc√™ deve ver que alguns novos arquivos apareceram na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados pelo ts#cloudscape-website" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados pelo gerador `ts#cloudscape-website`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos do app
          - static-websites/
            - **game-ui.ts** construct CDK para criar sua Game UI
        - core/
          - static-website.ts construct gen√©rico para website est√°tico
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout geral da p√°gina: cabe√ßalho, rodap√©, sidebar, etc
          - navitems.ts itens de navega√ß√£o da sidebar
      - hooks/
        - useAppLayout.tsx permite definir dinamicamente notifica√ß√µes, estilo da p√°gina, etc
      - routes/ rotas baseadas em arquivo do @tanstack/react-router
        - index.tsx p√°gina raiz '/' redireciona para '/welcome'
        - __root.tsx todos os componentes de p√°gina usam este como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** ponto de entrada do React
        - routeTree.gen.ts atualizado automaticamente pelo @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este √© o construct CDK que define nossa GameUI. Como visto, ele j√° configura o caminho para o bundle gerado de nossa UI baseada em Vite. Isso significa que no momento do `build`, o empacotamento ocorre dentro do target de build do projeto game-ui e sua sa√≠da √© usada aqui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra a inst√¢ncia do router para seguran√ßa de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este √© o ponto de entrada onde o React √© montado. Como mostrado, inicialmente apenas configura um `@tanstack/react-router` em uma configura√ß√£o de [`roteamento baseado em arquivo`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Isso significa que, enquanto o servidor de desenvolvimento estiver em execu√ß√£o, voc√™ pode simplesmente criar arquivos na pasta `routes` e o `@tanstack/react-router` criar√° a configura√ß√£o de arquivo boilerplate para voc√™, atualizando o arquivo `routeTree.gen.ts`. Este arquivo mant√©m todas as rotas de forma type-safe, o que significa que ao usar `<Link>`, a op√ß√£o `to` s√≥ mostrar√° rotas v√°lidas. Para mais informa√ß√µes, consulte a [documenta√ß√£o do `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Um componente que ser√° renderizado ao navegar para a rota `/welcome`. O `@tanstack/react-router` gerenciar√° a `Route` para voc√™ sempre que criar/mover este arquivo (desde que o servidor de desenvolvimento esteja em execu√ß√£o). Isso ser√° mostrado em uma se√ß√£o posterior deste tutorial.

</Drawer>

### UI do Jogo: Autentica√ß√£o

Agora vamos configurar nossa Game UI para exigir acesso autenticado via Amazon Cognito seguindo os passos abaixo:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Voc√™ deve ver que alguns arquivos novos apareceram/mudaram na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados pelo ts#cloudscape-website#auth" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados/atualizados pelo gerador `ts#cloudscape-website#auth`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para criar pools de usu√°rio/identidade
    - types/
      - src/
        - runtime-config.ts atualizado para adicionar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adiciona usu√°rio logado/logout ao cabe√ßalho
        - CognitoAuth/
          - index.ts gerencia login no Cognito
        - RuntimeConfig/
          - index.tsx busca o `runtime-config.json` e fornece aos filhos via contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Atualizado para adicionar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra a inst√¢ncia do router para seguran√ßa de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Os componentes `RuntimeConfigProvider` e `CognitoAuth` foram adicionados ao arquivo `main.tsx` via transforma√ß√£o AST. Isso permite que o componente `CognitoAuth` autentique com Amazon Cognito buscando o `runtime-config.json` que cont√©m a configura√ß√£o de conex√£o Cognito necess√°ria para fazer chamadas ao backend no destino correto.

</Drawer>

### UI do Jogo: Conectar √† Story API

Agora vamos configurar nossa Game UI para conectar √† nossa Story API criada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Voc√™ deve ver que alguns arquivos novos apareceram/mudaram na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados pela conex√£o UI -> FastAPI" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados/atualizados pelo gerador `api-connection`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado pelo StoryApi para assinar requisi√ß√µes
        - useStoryApiClient.tsx hook para construir um cliente StoryApi
        - useStoryApi.tsx hook para interagir com StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx provedor do cliente TanStack Query
        - StoryApiProvider.tsx Provedor para o hook TanStack Query do StoryApi
      - main.tsx Instrumenta o QueryClientProvider e StoryApiProvider
    - .gitignore ignora arquivos de cliente gerados
    - project.json atualizado para adicionar targets de gera√ß√£o de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json atualizado para emitir arquivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Este hook pode ser usado para fazer requisi√ß√µes autenticadas √† `StoryApi`. Como visto na implementa√ß√£o, ele usa o `StoryApi` que √© gerado no momento do build, ent√£o voc√™ ver√° um erro no seu IDE at√© que construamos nosso c√≥digo. Para mais detalhes sobre como o cliente √© gerado ou como consumir a API, consulte o <Link path="guides/api-connection/react-fastapi">guia React para FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

O componente provedor acima usa o hook `useStoryApiClient` e instancia o `StoryApiOptionsProxy`, que √© usado para construir op√ß√µes para hooks do TanStack Query. Voc√™ pode usar o hook correspondente `useStoryApi` para acessar este proxy de op√ß√µes, que fornece uma maneira de interagir com sua FastAPI de forma consistente com sua API tRPC.

Como `useStoryApiClient` nos fornece um iterador ass√≠ncrono para nossa API de streaming, usaremos o cliente vanilla diretamente neste tutorial.

<Aside type="caution">
Os arquivos `src/generated/story-api/*.gen.ts` nunca devem ser modificados manualmente, pois ser√£o re-gerados toda vez que voc√™ construir sua API.
</Aside>

</Drawer>

### UI do Jogo: Conectar √† Game API

Agora vamos configurar nossa Game UI para conectar √† nossa Game API criada anteriormente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Voc√™ deve ver que alguns arquivos novos apareceram/mudaram na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados pela conex√£o UI -> tRPC" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados/atualizados pelo gerador `api-connection`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura o cliente GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para chamar a GameApi
      - **main.tsx** injeta os provedores de cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useGameApi as useClient } from '../components/GameApiClientProvider';

export const useGameApi = useClient;
```

Este hook usa a [integra√ß√£o mais recente do React Query do tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client), permitindo que os usu√°rios interajam diretamente com `@tanstack/react-query` sem camadas adicionais de abstra√ß√£o. Para exemplos de como chamar APIs tRPC, consulte o <Link path="guides/api-connection/react-trpc#using-the-generated-code">guia de uso do hook tRPC</Link>.

<Aside>
O hook `useGameApi` √© diferente do `useStoryApi` pois n√£o requer um build para que mudan√ßas sejam refletidas, gra√ßas ao uso de [infer√™ncia TypeScript](https://trpc.io/docs/concepts) pelo tRPC. Isso permite que desenvolvedores fa√ßam mudan√ßas no backend que s√£o instantaneamente refletidas no frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra a inst√¢ncia do router para seguran√ßa de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

O arquivo `main.tsx` foi atualizado via transforma√ß√£o AST para injetar os provedores tRPC.

</Drawer>

### UI do Jogo: Infraestrutura

Agora o √∫ltimo subprojeto que precisamos criar √© para a infraestrutura CDK. Para criar isso, siga os passos abaixo:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Voc√™ deve ver que alguns novos arquivos apareceram/mudaram na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados pelo ts#infra" trigger="Clique aqui para examinar esses arquivos em detalhes.">
Abaixo est√° a lista de todos os arquivos gerados/atualizados pelo gerador `ts#infra`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqui
      - index.ts
      - **main.ts** ponto de entrada que define todas as stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json adiciona refer√™ncias
  - tsconfig.base.json adiciona alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Use isso para implantar seu pr√≥prio ambiente sandbox (assume credenciais CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Se voc√™ est√° vendo um erro de importa√ß√£o no seu IDE, isso ocorre porque nosso projeto de infraestrutura ainda n√£o tem uma refer√™ncia TypeScript configurada em seu tsconfig.json. O Nx foi [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para criar essas refer√™ncias *dinamicamente* sempre que um build/compile √© executado ou se voc√™ executar o comando `nx sync` manualmente. Para mais informa√ß√µes, consulte o <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guia TypeScript</Link>.</Aside>

Este √© o ponto de entrada para sua aplica√ß√£o CDK.

Ele est√° configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para executar valida√ß√£o de infraestrutura baseada no conjunto de regras configurado. Isso √© instrumentado p√≥s-s√≠ntese.

<Aside type="tip">
Pode haver casos onde voc√™ quer suprimir certas regras em recursos. Voc√™ pode fazer isso de duas formas:

###### Suprimir uma regra em um construct espec√≠fico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime a RULE_NAME para o construct dado
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir uma regra em um construct descendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime a RULE_NAME para o construct ou qualquer descendente se for inst√¢ncia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // O c√≥digo que define sua stack vai aqui
  }
}
```

Este √© onde instanciaremos nossos constructs CDK para construir nosso jogo de aventura.

</Drawer>

#### Atualizar nossa infraestrutura

Vamos atualizar nosso `packages/infra/src/stacks/application-stack.ts` para instanciar alguns de nossos constructs j√° gerados:


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Note que fornecemos integra√ß√µes padr√£o para nossas duas APIs. Por padr√£o, cada opera√ß√£o em nossa API √© mapeada para uma fun√ß√£o lambda individual para lidar com essa opera√ß√£o.

### Construindo nosso c√≥digo

<Drawer title="Comandos Nx" trigger="Agora √© hora de construir nosso c√≥digo pela primeira vez">
###### Targets √∫nicos vs m√∫ltiplos

O comando `run-many` executar√° um target em m√∫ltiplos subprojetos listados (`--all` os incluir√° todos). Ele garantir√° que depend√™ncias sejam executadas na ordem correta.

Voc√™ tamb√©m pode disparar um build (ou qualquer outra tarefa) para um target de projeto √∫nico executando o target diretamente no projeto. Por exemplo, se quisermos buildar o projeto `@dungeon-adventure/infra`, voc√™ pode executar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando depend√™ncias

Voc√™ tamb√©m pode visualizar suas depend√™ncias via:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

O Nx depende de [cache](https://nx.dev/concepts/how-caching-works) para reutilizar artefatos de builds anteriores e acelerar o desenvolvimento. H√° alguma configura√ß√£o necess√°ria para isso funcionar corretamente e pode haver casos onde voc√™ quer executar um build **sem usar o cache**. Para isso, basta adicionar o argumento `--skip-nx-cache` ao seu comando. Por exemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se por qualquer motivo voc√™ quiser limpar seu cache (armazenado na pasta `.nx`), execute:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Voc√™ deve receber o seguinte prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Esta mensagem indica que o NX detectou alguns arquivos que podem ser atualizados automaticamente. Neste caso, refere-se aos arquivos `tsconfig.json` que n√£o t√™m refer√™ncias TypeScript configuradas para projetos dependentes. Selecione a op√ß√£o **Yes, sync the changes and run the tasks** para prosseguir. Voc√™ deve notar que todos os erros de importa√ß√£o relacionados ao IDE s√£o resolvidos automaticamente, pois o gerador de sync adicionar√° as refer√™ncias TypeScript faltantes!

<Aside type="tip">
Se encontrar erros de lint, voc√™ pode executar o seguinte comando para corrigi-los automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Falha de build no Windows">
<Drawer trigger="Se voc√™ est√° no Windows e encontrar um erro de build, clique aqui." title="Falha de build no Windows">
Se encontrar um erro de build/synth para o projeto `@dungeon-adventure/infra`, isso √© esperado pois a biblioteca que instrumenta `cfn-guard` atualmente n√£o suporta Windows. H√° uma feature request acompanhando isso, mas por enquanto podemos simplesmente desabilitar o `cfn-guard` modificando o arquivo `packages/infra/src/main.ts` como segue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Use isso para implantar seu pr√≥prio ambiente sandbox (assume credenciais CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos os artefatos constru√≠dos agora est√£o dispon√≠veis na pasta `dist/` na raiz do monorepo. Esta √© uma pr√°tica padr√£o ao usar projetos gerados pelo `@aws/nx-plugin`, pois n√£o polui sua √°rvore de arquivos com arquivos gerados. Caso queira limpar seus arquivos, basta deletar a pasta `dist/` sem se preocupar com arquivos gerados espalhados.

Parab√©ns! Voc√™ criou todos os subprojetos necess√°rios para come√ßar a implementar o n√∫cleo do nosso jogo Dunegeon Adventure.  üéâüéâüéâ