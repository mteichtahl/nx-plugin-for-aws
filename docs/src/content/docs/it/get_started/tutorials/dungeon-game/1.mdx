---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato dall'IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 1: Configurazione del monorepo

Iniziamo creando un nuovo monorepo. Esegui il seguente comando dalla directory desiderata:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Questo configurerà un monorepo NX nella directory `dungeon-adventure` che potrai aprire in VSCode. Dovrebbe apparire così:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sottoprogetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura la CLI NX e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json esteso da tutti i sottoprogetti basati su Node
- tsconfig.json
</FileTree>

Ora siamo pronti per iniziare a creare i vari sottoprogetti utilizzando `@aws/nx-plugin`.

<Aside type="tip">È una best practice assicurarsi che tutti i file non staged siano commitati in Git prima di eseguire qualsiasi generatore. Questo permette di visualizzare le modifiche dopo l'esecuzione del generatore tramite `git diff`</Aside>

### Game API

Iniziamo creando la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.

<Aside>
Il `package.json` principale è ora configurato con un `type` impostato a `module`, il che significa che ESM è il tipo di modulo predefinito per tutti i sottoprogetti Node gestiti da `@aws/nx-plugin`. Per maggiori dettagli sui progetti TypeScript, consulta la <Link path="guides/typescript-project">guida ts#project</Link>.
</Aside>

<Drawer title="File aggiornati da ts#trpc-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati dal generatore `ts#trpc-api`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - apis/
            - **game-api.ts** costrutto CDK per creare la tua API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ costrutti CDK generici
          - api/
            - rest-api.ts costrutto base per un'API Gateway Rest API
            - trpc-utils.ts utility per i costrutti CDK delle API tRPC
            - utils.ts utility per i costrutti API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia utilizzata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla tipicamente utilizzato per chiamate machine-to-machine in TS
        - index.ts
        - sigv4.ts
      - middleware/ strumentazione Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definizioni di input e output per la tua API
        - **echo.ts**
      - procedures/ implementazioni specifiche per le procedure/route dell'API
        - **echo.ts**
      - index.ts
      - init.ts configura il contesto e i middleware
      - local-server.ts utilizzato per eseguire il server tRPC localmente
      - **router.ts** punto di ingresso per il lambda handler che definisce tutte le procedure
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo alcuni file chiave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Il router definisce il punto di ingresso per la tua API tRPC ed è dove dichiarerai tutti i metodi dell'API. Come puoi vedere sopra, abbiamo un metodo chiamato `echo` con la sua implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file contiene l'implementazione del metodo `echo` ed è fortemente tipizzato dichiarando le sue strutture dati di input e output.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni degli schema tRPC sono definite utilizzando [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Proprietà per creare un costrutto GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API
 * specificamente per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // L'accesso granulare machine-to-machine può essere definito qui utilizzando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni procedura nella nostra API tRPC, puntando all'implementazione dell'API già bundleizzata. Ciò significa che al momento di `cdk synth` non avviene il bundling (a differenza di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poiché è già stato effettuato come parte del target di build del progetto backend.

</Drawer>

### Story API

Ora creiamo la nostra Story API. Per farlo, creiamo un'API Fast chiamata `StoryApi` seguendo questi passaggi:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.
<Drawer title="File aggiornati da py#fast-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati dal generatore `py#fast-api`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- .venv/ singolo ambiente virtuale per il monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - apis/
            - **story-api.ts** costrutto CDK per creare la tua Fast API
            - index.ts aggiornato per esportare la nuova story-api
      - project.json aggiornato per aggiungere una dipendenza di build su story_api
    - types/ tipi condivisi
      - src/
        - **runtime-config.ts** aggiornato per aggiungere StoryApi
  - story_api/
    - story_api/ modulo Python
      - init.py configura Powertools, FastAPI e middleware
      - **main.py** punto di ingresso per il lambda contenente tutte le route
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Proprietà per creare un costrutto StoryApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API
 * specificamente per StoryApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // L'accesso granulare machine-to-machine può essere definito qui utilizzando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Questo è il costrutto CDK che definisce la nostra StoryApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni operazione definita nella nostra FastAPI, puntando all'implementazione dell'API già bundleizzata. Ciò significa che al momento di `cdk synth` non avviene il bundling (a differenza di [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) poiché è già stato effettuato come parte del target di build del progetto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Ecco un esempio del generatore che esegue una trasformazione AST preservando tutto il codice esistente e aggiornando la definizione di `IRuntimeConfig`. Come puoi vedere, `StoryApi` è stato aggiunto alla definizione, il che significa che quando verrà consumato dal frontend, garantirà la type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Questo è dove verranno definiti tutti i metodi dell'API. Come puoi vedere qui, abbiamo un metodo `read_root` mappato alla route `GET /`. Puoi utilizzare [Pydantic](https://docs.pydantic.dev/latest/) per dichiarare input e output dei metodi e garantire la type safety.

</Drawer>

### Game UI: Website

Ora creiamo l'interfaccia utente che permetterà di interagire con il gioco. Per farlo, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati dal generatore `ts#cloudscape-website`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - static-websites/
            - **game-ui.ts** costrutto CDK per creare la tua Game UI
        - core/
          - static-website.ts costrutto generico per siti web statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout generale della pagina: header, footer, sidebar, ecc.
          - navitems.ts elementi di navigazione della sidebar
      - hooks/
        - useAppLayout.tsx permette di impostare dinamicamente elementi come notifiche, stile della pagina, ecc.
      - routes/ route basate su file con @tanstack/react-router
        - index.tsx pagina root '/' reindirizza a '/welcome'
        - __root.tsx tutte le pagine utilizzano questo componente come base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto di ingresso di React
        - routeTree.gen.ts aggiornato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameUI. Come puoi vedere, ha già configurato il percorso del file per il bundle generato dalla UI basata su Vite. Ciò significa che al momento del `build`, il bundling avviene all'interno del target di build del progetto game-ui e il suo output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo è il punto di ingresso dove viene montato React. Come mostrato, inizialmente configura un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Ciò significa che, finché il server di sviluppo è in esecuzione, puoi semplicemente creare file nella cartella `routes` e `@tanstack/react-router` creerà automaticamente il setup boilerplate aggiornando il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, quindi quando usi `<Link>`, l'opzione `to` mostrerà solo route valide. Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente che verrà renderizzato quando si naviga alla route `/welcome`. `@tanstack/react-router` gestirà la `Route` per te ogni volta che crei/sposti questo file (finché il dev server è in esecuzione). Questo verrà mostrato in una sezione successiva di questo tutorial.

</Drawer>

### Game UI: Auth

Ora configuriamo la nostra Game UI per richiedere l'accesso autenticato tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Dovresti vedere alcuni nuovi file o modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website#auth" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati/aggiornati dal generatore `ts#cloudscape-website#auth`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts costrutto CDK per creare pool di utenti/identità
    - types/
      - src/
        - runtime-config.ts aggiornato per aggiungere cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge l'utente loggato/logout all'header
        - CognitoAuth/
          - index.ts gestisce il login in Cognito
        - RuntimeConfig/
          - index.tsx recupera il `runtime-config.json` e lo fornisce ai figli via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato per aggiungere Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione di connessione necessaria per effettuare chiamate al backend verso la destinazione corretta.

</Drawer>

### Game UI: Connessione a Story API

Ora configuriamo la nostra Game UI per connettersi alla Story API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Dovresti vedere alcuni nuovi file o modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> FastAPI api-connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilizzato da StoryApi per firmare le richieste
        - useStoryApiClient.tsx hook per costruire un client StoryApi
        - useStoryApi.tsx hook per interagire con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx provider del client TanStack Query
        - StoryApiProvider.tsx Provider per l'hook TanStack Query di StoryApi
      - main.tsx Inietta QueryClientProvider e StoryApiProvider
    - .gitignore ignora i file client generati
    - project.json aggiornato per aggiungere target per generare hook openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json aggiornato per emettere un file openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Questo hook può essere utilizzato per effettuare richieste API autenticate alla `StoryApi`. Come puoi vedere nell'implementazione, utilizza `StoryApi` generato al momento del build, quindi vedrai un errore nel tuo IDE finché non compiliamo il codice. Per dettagli su come viene generato il client o su come consumare l'API, consulta la <Link path="guides/api-connection/react-fastapi">guida React to FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Il componente provider sopra utilizza l'hook `useStoryApiClient` e istanzia `StoryApiOptionsProxy`, che viene utilizzato per costruire le opzioni per gli hook TanStack Query. Puoi utilizzare l'hook corrispondente `useStoryApi` per accedere a questo proxy di opzioni, che fornisce un modo per interagire con la tua FastAPI in modo coerente con la tua API tRPC.

Poiché `useStoryApiClient` ci fornisce un async iterator per la nostra API di streaming, in questo tutorial utilizzeremo direttamente il client vanilla.

<Aside type="caution">
I file `src/generated/story-api/*.gen.ts` non devono mai essere modificati manualmente poiché verranno rigenerati ogni volta che costruisci la tua API.
</Aside>

</Drawer>

### Game UI: Connessione a Game API

Ora configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Dovresti vedere alcuni nuovi file o modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> tRPC api-connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura il client GameAPI
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider del client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useGameApi as useClient } from '../components/GameApiClientProvider';

export const useGameApi = useClient;
```

Questo hook utilizza l'ultima [integrazione React Query di tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida all'uso dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` è diverso da `useStoryApi` poiché non richiede una build per riflettere le modifiche grazie all'utilizzo di [TypeScript inference](https://trpc.io/docs/concepts) da parte di tRPC. Questo permette agli sviluppatori di apportare modifiche al backend che si riflettono istantaneamente nel frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` è stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Ora l'ultimo sottoprogetto che dobbiamo creare è per l'infrastruttura CDK. Per crearlo, segui questi passaggi:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Dovresti vedere alcuni nuovi file o modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#infra" trigger="Clicca qui per esaminare questi file in dettaglio.">
Ecco l'elenco di tutti i file generati/aggiornati dal generatore `ts#infra`. Esamineremo alcuni file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** punto di ingresso che definisce tutti gli stack
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunge riferimenti
  - tsconfig.base.json aggiunge alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Utilizza questo per deployare il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Se vedi un errore di importazione nel tuo IDE, è perché il nostro progetto infrastruttura non ha ancora un riferimento TypeScript configurato nel suo tsconfig.json. Nx è stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguito un build/compile o se esegui manualmente il comando `nx sync`. Per maggiori informazioni consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guida TypeScript</Link>.</Aside>

Questo è il punto di ingresso per la tua applicazione CDK.

È configurato per utilizzare [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) per eseguire la validazione dell'infrastruttura basata sul set di regole configurato. Questo viene strumentato post-sintesi.

<Aside type="tip">
Ci possono essere casi in cui vuoi sopprimere determinate regole su risorse. Puoi farlo in due modi:

###### Sopprimi una regola su un costrutto specifico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// sopprime la RULE_NAME per il costrutto specificato.
suppressRule(construct, 'RULE_NAME');
```

###### Sopprimi una regola su un costrutto discendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Sopprime la RULE_NAME per il costrutto o qualsiasi suo discendente se è un'istanza di Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce il tuo stack va qui
  }
}
```

Questo è dove istanzieremo i nostri costrutti CDK per costruire il nostro gioco Dungeon Adventure.

</Drawer>

#### Aggiorniamo la nostra infrastruttura

Modifichiamo il file `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei costrutti già generati:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota che forniamo integrazioni predefinite per le nostre due API. Di default, ogni operazione nelle nostre API è mappata a una singola funzione lambda per gestire quell'operazione.

### Costruiamo il codice

<Drawer title="Comandi Nx" trigger="Ora è il momento di costruire il nostro codice per la prima volta">
###### Target singoli vs multipli

Il comando `run-many` eseguirà un target su più sottoprogetti elencati (`--all` li selezionerà tutti). Garantirà che le dipendenze siano eseguite nell'ordine corretto.

Puoi anche attivare un build (o qualsiasi altro task) per un singolo progetto eseguendo il target direttamente sul progetto. Ad esempio, se vogliamo costruire il progetto `@dungeon-adventure/infra`, puoi eseguire:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizzare le dipendenze

Puoi visualizzare le tue dipendenze tramite:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per riutilizzare artefatti da build precedenti e velocizzare lo sviluppo. È necessaria una configurazione per far funzionare correttamente questa funzionalità e ci possono essere casi in cui vuoi eseguire un build **senza utilizzare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al tuo comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo vuoi cancellare la tua cache (memorizzata nella cartella `.nx`), puoi eseguire:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Dovresti ricevere il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati per i progetti dipendenti. Seleziona l'opzione **Yes, sync the changes and run the tasks** per procedere. Noterai che tutti gli errori di importazione nel tuo IDE verranno risolti automaticamente poiché il generatore di sync aggiungerà i riferimenti TypeScript mancanti!

<Aside type="tip">
Se incontri errori di lint, puoi eseguire questo comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Fallimento build su Windows">
<Drawer trigger="Se sei su Windows e incontri un errore di build, clicca qui." title="Fallimento build su Windows">
Se incontri un errore di build/synth per il progetto `@dungeon-adventure/infra`, questo è previsto poiché la libreria che strumenta `cfn-guard` attualmente non supporta Windows. C'è una richiesta di feature che tiene traccia di questo, ma nel frattempo possiamo semplicemente disabilitare `cfn-guard` modificando il file `packages/infra/src/main.ts` come segue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Utilizza questo per deployare il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tutti gli artefatti di build sono ora disponibili nella cartella `dist/` alla radice del monorepo. Questa è una pratica standard quando si utilizzano progetti generati da `@aws/nx-plugin` poiché non inquina l'albero dei file con file generati. Se vuoi pulire i file, puoi semplicemente eliminare la cartella `dist/` senza preoccuparti di file generati sparsi nell'albero.

Complimenti! Hai creato tutti i sottoprogetti necessari per iniziare a implementare il cuore del gioco Dungeon Adventure. 🎉🎉🎉