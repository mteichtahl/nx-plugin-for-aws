---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura dungeon alimentato da IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 1: Configurazione del monorepo

Iniziamo creando un nuovo monorepo. All'interno della directory desiderata, esegui il seguente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Questo configurer√† un monorepo NX all'interno della directory `dungeon-adventure` che potrai aprire in VSCode. Dovrebbe apparire come segue:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sottoprogetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura le impostazioni predefinite della CLI Nx e del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json a seconda del gestore di pacchetti
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json tutti i sottoprogetti basati su Node estendono questo file
- tsconfig.json
</FileTree>

Ora siamo pronti per iniziare a creare i diversi sottoprogetti utilizzando il plugin `@aws/nx-plugin`.

<Aside type="tip">√à una best practice assicurarsi che tutti i file non tracciati siano commitati in Git prima di eseguire qualsiasi generatore. Questo ti permette di vedere cosa √® cambiato dopo aver eseguito il generatore tramite `git diff`</Aside>

### Game API

Iniziamo creando la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Dovresti vedere alcuni nuovi file apparire nel tuo albero delle directory.

<Aside>
Il `package.json` principale √® ora configurato con un `type` impostato su `module`, il che significa che ESM √® il tipo di modulo predefinito per tutti i sottoprogetti Node gestiti dal plugin `@aws/nx-plugin`. Per maggiori dettagli sul lavoro con progetti TypeScript, consulta la <Link path="guides/typescript-project">guida ts#project</Link>.
</Aside>

<Drawer title="File aggiornati da ts#trpc-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati dal generatore `ts#trpc-api`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - apis/
            - **game-api.ts** costrutto CDK per creare l'API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ costrutti CDK generici
          - api/
            - rest-api.ts costrutto base CDK per un'API Gateway Rest API
            - trpc-utils.ts utility per i costrutti CDK delle API tRPC
            - utils.ts utility per i costrutti delle API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia utilizzata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/
    - backend/ codice di implementazione tRPC
      - src/
        - client/ client vanilla tipicamente utilizzato per chiamate machine-to-machine in TS
          - index.ts
          - sigv4.ts
        - middleware/ strumentazione Powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementazioni specifiche per le procedure/route dell'API
          - **echo.ts**
        - index.ts
        - init.ts configura il contesto e il middleware
        - local-server.ts utilizzato per eseguire il server tRPC localmente
        - **router.ts** punto di ingresso per l'handler Lambda che definisce tutte le procedure
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo alcuni dei file chiave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Il router definisce il punto di ingresso per la tua API tRPC ed √® il luogo in cui dichiarerai tutti i metodi dell'API. Come puoi vedere sopra, abbiamo un metodo chiamato `echo` con la sua implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file √® l'implementazione del metodo `echo` e, come puoi vedere, √® fortemente tipizzato dichiarando le sue strutture dati di input e output. Importa queste definizioni dal progetto `:dungeon-adventure/game-api-schema`, che √® un [alias](https://www.typescriptlang.org/tsconfig/paths.html) per il progetto schema.

<Aside type="tip">Se vedi un errore di importazione nel tuo IDE, √® perch√© il nostro backend non ha ancora un riferimento TypeScript configurato nel suo tsconfig.json. Nx √® stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguita una build/compilazione o se esegui manualmente il comando `nx sync`. Per maggiori informazioni, consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guida TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni degli schema tRPC sono definite utilizzando [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union di stringhe per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Propriet√† per la creazione di un costrutto GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API REST AWS API Gateway
 * specificamente per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione come
   * una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK scope
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/backend/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto √® distribuito di chiamare l'API.
          // L'accesso granulare machine-to-machine pu√≤ essere definito qui utilizzando principal pi√π specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Questo √® il costrutto CDK che definisce la nostra GameApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni procedura nella nostra API tRPC, puntando all'implementazione dell'API gi√† bundled. Ci√≤ significa che al momento di `cdk synth`, il bundling non avviene (contrariamente all'uso di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poich√© lo abbiamo gi√† incluso come parte del target di build del progetto backend.

</Drawer>

### Story API

Ora creiamo la nostra Story API. Per farlo, creiamo un'API Fast chiamata `StoryApi` seguendo questi passaggi:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire nel tuo albero delle directory.
<Drawer title="File aggiornati da py#fast-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati dal generatore `py#fast-api`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- .venv/ singolo ambiente virtuale per il monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - apis/
            - **story-api.ts** costrutto CDK per creare la tua Fast API
            - index.ts aggiornato per esportare la nuova story-api
      - project.json aggiornato per aggiungere una dipendenza di build su story_api
    - types/ tipi condivisi
      - src/
        - **runtime-config.ts** aggiornato per aggiungere la StoryApi
  - story_api/
    - story_api/ modulo Python
      - init.py configura Powertools, FastAPI e middleware
      - **main.py** punto di ingresso per la lambda contenente tutte le route
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propriet√† per la creazione di un costrutto StoryApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API REST AWS API Gateway
 * specificamente per StoryApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione come
   * una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK scope
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto √® distribuito di chiamare l'API.
          // L'accesso granulare machine-to-machine pu√≤ essere definito qui utilizzando principal pi√π specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Questo √® il costrutto CDK che definisce la nostra StoryApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni operazione definita nella nostra FastAPI, puntando all'implementazione dell'API gi√† bundled. Ci√≤ significa che al momento di `cdk synth`, il bundling non avviene (contrariamente a [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) poich√© lo abbiamo gi√† incluso come parte del target di build del progetto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Ecco un esempio del generatore che esegue una trasformazione AST preservando tutto il codice esistente e aggiungendo un aggiornamento. Qui puoi vedere che `StoryApi` √® stato aggiunto alla definizione `IRuntimeConfig`, il che significa che quando questo verr√† consumato dal nostro frontend, garantir√† la type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Questo √® dove verranno definiti tutti i metodi della tua API. Come puoi vedere qui, abbiamo un metodo `read_root` mappato alla route `GET /`. Puoi utilizzare [Pydantic](https://docs.pydantic.dev/latest/) per dichiarare gli input e gli output dei tuoi metodi per garantire la type safety.

</Drawer>

### Game UI: Website

Ora creiamo l'interfaccia utente che ti permetter√† di interagire con il gioco. Per farlo, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati dal generatore `ts#cloudscape-website`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - static-websites/
            - **game-ui.ts** costrutto CDK per creare la tua Game UI
        - core/
          - static-website.ts costrutto generico per siti web statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout generale della pagina: header, footer, sidebar, ecc.
          - navitems.ts elementi di navigazione della sidebar
      - hooks/
        - useAppLayout.tsx permette di impostare dinamicamente elementi come notifiche, stile della pagina, ecc.
      - routes/ route basate su file di @tanstack/react-router
        - index.tsx pagina root '/' reindirizza a '/welcome'
        - __root.tsx tutte le pagine utilizzano questo componente come base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto di ingresso React
        - routeTree.gen.ts questo file viene aggiornato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo √® il costrutto CDK che definisce la nostra GameUI. Come puoi vedere, ha gi√† configurato il percorso del file al bundle generato per la nostra UI basata su Vite. Ci√≤ significa che al momento della `build`, il bundling avviene all'interno del target di build del progetto game-ui e il suo output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo √® il punto di ingresso dove React viene montato. Come mostrato, inizialmente configura un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Ci√≤ significa che, finch√© il server di sviluppo √® in esecuzione, puoi semplicemente creare file all'interno della cartella `routes` e `@tanstack/react-router` creer√† automaticamente la configurazione boilerplate per te, aggiornando il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, il che significa che quando usi `<Link>`, l'opzione `to` mostrer√† solo route valide. Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente che verr√† renderizzato quando si naviga alla route `/welcome`. `@tanstack/react-router` gestir√† la `Route` per te ogni volta che crei/sposti questo file (finch√© il dev server √® in esecuzione). Questo verr√† mostrato in una sezione successiva di questo tutorial.

</Drawer>

### Game UI: Auth

Ora configuriamo la nostra Game UI per richiedere l'accesso autenticato tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/cambiare nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website#auth" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati/aggiornati dal generatore `ts#cloudscape-website#auth`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts costrutto CDK per creare pool di utenti/identit√†
    - types/
      - src/
        - runtime-config.ts aggiornato per aggiungere cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge l'utente loggato/logout all'header
        - CognitoAuth/
          - index.ts gestisce il login in Cognito
        - RuntimeConfig/
          - index.tsx recupera il `runtime-config.json` e lo fornisce ai figli via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato per aggiungere Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione di connessione Cognito necessaria per effettuare le chiamate al backend verso la destinazione corretta.

</Drawer>

### Game UI: Connessione a Story API

Ora configuriamo la nostra Game UI per connettersi alla Story API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/cambiare nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> FastAPI api-connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilizzato da StoryApi per firmare le richieste
        - useStoryApiClient.tsx hook per costruire un client StoryApi
        - useStoryApi.tsx hook per interagire con StoryApi utilizzando TanStack Query
      - components/
        - QueryClientProvider.tsx provider del client TanStack Query
        - StoryApiProvider.tsx Provider per l'hook TanStack Query di StoryApi
      - main.tsx Strumenta QueryClientProvider e StoryApiProvider
    - .gitignore ignora i file client generati
    - project.json aggiornato per aggiungere target per la generazione di hook openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json aggiornato per emettere un file openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Questo hook pu√≤ essere utilizzato per effettuare richieste API autenticate alla `StoryApi`. Come puoi vedere nell'implementazione, utilizza `StoryApi` che viene generato al momento della build, quindi vedrai un errore nel tuo IDE finch√© non eseguiremo la build del codice. Per maggiori dettagli su come viene generato il client o su come consumare l'API, consulta la <Link path="guides/api-connection/react-fastapi">guida React to FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Il componente provider sopra utilizza l'hook `useStoryApiClient` e istanzia `StoryApiOptionsProxy`, che viene utilizzato per costruire le opzioni per gli hook TanStack Query. Puoi utilizzare l'hook corrispondente `useStoryApi` per accedere a questo proxy di opzioni, che fornisce un modo per interagire con la tua FastAPI in modo coerente con la tua API tRPC.

Poich√© `useStoryApiClient` ci fornisce un async iterator per la nostra API di streaming, in questo tutorial utilizzeremo direttamente il client vanilla.

<Aside type="caution">
I file `src/generated/story-api/*.gen.ts` non devono mai essere modificati manualmente poich√© verranno rigenerati ogni volta che esegui la build della tua API.
</Aside>

</Drawer>

### Game UI: Connessione a Game API

Ora configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/cambiare nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> tRPC api-connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx tutte le API tRPC configurate
          - TrpcClientProviders.tsx crea un client provider per ogni API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider client tRPC
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Questo hook utilizza l'ultima [integrazione React Query di tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client), permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida all'uso dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` √® diverso dall'hook `useStoryApi` perch√© non richiede una build per riflettere le modifiche, grazie all'uso di [TypeScript inference](https://trpc.io/docs/concepts) da parte di tRPC. Questo permette agli sviluppatori di apportare modifiche al backend che vengono immediatamente riflesse nel frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` √® stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Ora l'ultimo sottoprogetto che dobbiamo creare √® per l'infrastruttura CDK. Per crearlo, segui questi passaggi:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/cambiare nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#infra" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito √® riportato l'elenco di tutti i file generati/aggiornati dal generatore `ts#infra`. Esamineremo alcuni dei file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** punto di ingresso che definisce tutti gli stack
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunge riferimenti
  - tsconfig.base.json aggiunge alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Utilizza questo per distribuire il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Questo √® il punto di ingresso per la tua applicazione CDK.

√à configurato per utilizzare [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) per eseguire la validazione dell'infrastruttura basata sul set di regole configurato. Questo viene strumentato post-sintesi.

<Aside type="tip">
Potrebbero esserci casi in cui desideri sopprimere determinate regole su risorse specifiche. Puoi farlo in due modi:

###### Sopprimi una regola su un costrutto specifico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// sopprime la RULE_NAME per il costrutto specificato.
suppressRule(construct, 'RULE_NAME');
```

###### Sopprimi una regola su un costrutto discendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Sopprime la RULE_NAME per il costrutto o qualsiasi suo discendente se √® un'istanza di Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce il tuo stack va qui
  }
}
```

Questo √® dove istanzieremo i nostri costrutti CDK per costruire il nostro gioco dungeon adventure.

</Drawer>

#### Aggiorniamo la nostra infrastruttura

Apportiamo un aggiornamento al file `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei nostri costrutti gi√† generati:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota che forniamo integrazioni predefinite per le nostre due API. Per impostazione predefinita, ogni operazione nella nostra API √® mappata a una singola funzione lambda per gestire quell'operazione.

### Compiliamo il nostro codice

<Drawer title="Comandi Nx" trigger="Ora √® il momento di compilare il nostro codice per la prima volta">
###### Target singoli vs multipli

Il comando `run-many` eseguir√† un target su pi√π sottoprogetti elencati (`--all` li selezioner√† tutti). Garantir√† che le dipendenze vengano eseguite nell'ordine corretto.

Puoi anche attivare una build (o qualsiasi altro task) per un target di progetto singolo eseguendo il target direttamente sul progetto. Ad esempio, se vogliamo buildare il progetto `@dungeon-adventure/infra`, puoi eseguire:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizzare le dipendenze

Puoi anche visualizzare le tue dipendenze tramite:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per riutilizzare gli artefatti di build precedenti e velocizzare lo sviluppo. √à necessaria una configurazione per far funzionare correttamente questa funzionalit√† e potrebbero esserci casi in cui desideri eseguire una build **senza utilizzare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al tuo comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo desideri cancellare la tua cache (memorizzata nella cartella `.nx`), puoi eseguire:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Dovresti ricevere il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati per i progetti dipendenti. Seleziona l'opzione **Yes, sync the changes and run the tasks** per procedere. Dovresti notare che tutti gli errori di importazione nel tuo IDE vengono risolti automaticamente, poich√© il generatore di sync aggiunger√† i riferimenti TypeScript mancanti!

<Aside type="tip">
Se incontri errori di lint, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Errore di build su Windows">
<Drawer trigger="Se sei su Windows e incontri un errore di build, clicca qui." title="Errore di build su Windows">
Se incontri un errore di build/synth per il progetto `@dungeon-adventure/infra`, questo √® previsto poich√© la libreria che strumenta `cfn-guard` attualmente non supporta Windows. C'√® una richiesta di funzionalit√† che tiene traccia di questo, ma nel frattempo possiamo semplicemente disabilitare `cfn-guard` modificando il file `packages/infra/src/main.ts` come segue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Utilizza questo per distribuire il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tutti gli artefatti compilati sono ora disponibili all'interno della cartella `dist/` situata alla radice del monorepo. Questa √® una pratica standard quando si utilizzano progetti generati dal plugin `@aws/nx-plugin`, poich√© non inquina l'albero delle directory con file generati. Nel caso desideri pulire i file, puoi semplicemente eliminare la cartella `dist/` senza preoccuparti di file generati sparsi nell'albero delle directory.

Complimenti! Hai creato tutti i sottoprogetti necessari per iniziare a implementare il cuore del nostro gioco Dunegeon Adventure.  üéâüéâüéâ