---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura dungeon alimentato da IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 2: Implementazione dell'API del gioco

Inizieremo implementando la nostra Game API. Per farlo, dobbiamo creare 4 API in totale:

1. `createGame` - creer√† una nuova istanza di gioco.
2. `queryGames` - restituir√† una lista paginata di giochi salvati precedentemente.
3. `saveAction` - salver√† un'azione per un determinato gioco.
4. `queryActions` - restituir√† una lista paginata di tutte le azioni relative a un gioco.

### Schema dell'API

Per definire gli input e output della nostra API, creiamo lo schema utilizzando [Zod](https://zod.dev/) all'interno del progetto `packages/game-api/schema/src` come segue:

<Tabs>
  <TabItem label="types/action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/action.ts.template" />
  </TabItem>
  <TabItem label="types/common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/common.ts.template" />
  </TabItem>
  <TabItem label="types/game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/game.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `./procedures/echo.ts` dato che non lo utilizzeremo in questo progetto.

<Aside type="tip">
Come puoi vedere sopra, per ogni schema definito in Zod, esportiamo anche un'interfaccia utilizzando la sintassi `z.TypeOf`. Questo converte la nostra definizione Zod in un'interfaccia TypeScript senza duplicare gli sforzi!
</Aside>

### Modellazione delle entit√†

Il diagramma ER per la nostra applicazione √® il seguente:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

Implementeremo il nostro database in DynamoDB e utilizzeremo la libreria client [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) per semplificare il tutto. Per iniziare, dobbiamo prima installare `electrodb` eseguendo il seguente comando:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Tutte le dipendenze vengono aggiunte al `package.json` principale poich√© `@aws/nx-plugin` segue il principio della [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Per maggiori informazioni, consulta la <Link path="guides/typescript-project#dependencies">guida ts#project</Link>.
</Aside>

Ora creiamo i seguenti file all'interno della cartella `packages/game-api/backend/src/entities` per definire le nostre entit√† ElectroDB secondo il diagramma ER sopra:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
</Tabs>

ElectroDB √® molto potente e ci permette non solo di definire i nostri tipi, ma pu√≤ anche fornire valori predefiniti per certi campi come i timestamp sopra. Inoltre, ElectroDB segue il [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), considerata la best practice con DynamoDB.

<Aside>
Sebbene ElectroDB supporti le [collections](https://electrodb.dev/en/modeling/collections/), in questo tutorial abbiamo scelto di non utilizzarle per semplicit√†.
</Aside>

### Aggiunta del client DynamoDB al contesto tRPC

Dato che abbiamo bisogno di accedere al client DynamoDB in ciascuna delle nostre procedure, vogliamo creare un'unica istanza del client da passare tramite contesto. Per farlo, apporta le seguenti modifiche in `packages/game-api/backend/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Questo √® un plugin che strumentiamo per creare il `DynamoDBClient` e iniettarlo nel contesto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Estendiamo il nostro `IMiddlewareContext` per aggiungere `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Il plugin DynamoDB viene strumentato.

<Aside>
L'API `concat` collega il nostro middleware alle procedure definite. Per dettagli aggiuntivi, consulta la [guida concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definizione delle procedure

Ora √® il momento di implementare i metodi dell'API. Apporta le seguenti modifiche in `packages/game-api/backend/src/procedures`:

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `echo.ts` (da `packages/game-api/backend/src/procedures`) dato che non lo utilizzeremo in questo progetto.

### Configurazione del router

Ora che abbiamo definito le nostre procedure, colleghiamole alla nostra API. Aggiorna il seguente file come segue:

<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />

### Infrastruttura

Il passo finale √® aggiornare la nostra infrastruttura per creare la tabella DynamoDB e concedere i permessi per eseguire operazioni dalla Game API. Modifica `packages/infra/src` come segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Nota che, poich√© ogni procedura √® gestita da una singola funzione lambda, possiamo seguire il principio del minimo privilegio assegnando solo i permessi di lettura/scrittura necessari in base all'implementazione della procedura.
:::
  </TabItem>
</Tabs>

### Deployment e testing

Prima di tutto, compiliamo il codice:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Se incontri errori di linting, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Ora puoi distribuire l'applicazione eseguendo:

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox']} />

Il primo deployment richieder√† circa 8 minuti. I deployment successivi richiederanno circa 2 minuti.

:::tip
Se stai modificando il codice delle funzioni lambda, puoi distribuire con il flag `--hotswap` dopo aver compilato il codice per un tempo di deployment molto pi√π breve (2-3 secondi).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox --hotswap']} />
:::

<Drawer title="Comando di deployment" trigger="Puoi anche distribuire tutti gli stack contemporaneamente. Clicca qui per maggiori dettagli.">

Puoi distribuire tutti gli stack contenuti nell'applicazione CDK eseguendo:

<NxCommands commands={['run @dungeon-adventure/infra:deploy --all']} />

**Non √® raccomandato** poich√© potresti voler separare le fasi di deployment in stack diversi `es. infra-prod`. In questo caso il flag `--all` tenter√† di distribuire tutti gli stack, con il rischio di deployment indesiderati!

</Drawer>

Una volta completato il deployment, dovresti vedere output simili ai seguenti _(alcuni valori sono stati oscurati)_:

```bash
dungeon-adventure-infra-sandbox
dungeon-adventure-infra-sandbox: deploying... [2/2]

 ‚úÖ  dungeon-adventure-infra-sandbox

‚ú®  Tempo di deployment: 354s

Outputs:
dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX = dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY
dungeon-adventure-infra-sandbox.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-infra-sandbox.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Possiamo testare la nostra API in due modi:
<ul>
<li>Avviando un'istanza locale del backend tRPC e invocando le API con `curl`.</li>
<li>
<Drawer title="Curl abilitato Sigv4" trigger="Chiamare l'API distribuita utilizzando curl con autenticazione Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Puoi aggiungere questo script al tuo file `.bashrc` (e eseguire `source`) o incollarlo direttamente nel terminale.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Esempi di utilizzo:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Aggiungi questa funzione al tuo profilo PowerShell o incollala nella sessione corrente.
```powershell
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )
    
    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token
    
    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Esempi di utilizzo:

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function url
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Locale">
    Avvia il server locale `game-api` con:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX` dall'output del deploy CDK per sostituire il placeholder evidenziato.
    </Aside>

    Una volta avviato il server, puoi chiamarlo con:

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Distribuito">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox.GameApiGameApiEndpointXXX` dall'output del deploy CDK e imposta la regione di conseguenza.
    </Aside>
  </TabItem>
</Tabs>

:::note
Il parametro `%7B%7D` passato per testare l'API √® un oggetto JSON vuoto codificato URI (`{}`).
:::

Se il comando viene eseguito correttamente, dovresti vedere una risposta come:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Complimenti, hai creato e distribuito la tua prima API utilizzando tRPC! üéâüéâüéâ