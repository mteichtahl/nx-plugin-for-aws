---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura dungeon alimentato da IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 2: Implementazione dell'API del gioco

Inizieremo implementando la nostra Game API. Per farlo, dobbiamo creare 4 API in totale:

1. `createGame` - creer√† una nuova istanza di gioco.
2. `queryGames` - restituir√† una lista paginata di partite salvate precedentemente.
3. `saveAction` - salver√† un'azione per una partita specifica.
4. `queryActions` - restituir√† una lista paginata di tutte le azioni relative a una partita.

### Schema dell'API

Per definire gli input e output della nostra API, creiamo lo schema utilizzando [Zod](https://zod.dev/) nella directory `packages/game-api/src/schema` come segue:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `packages/game-api/src/schema/echo.ts` dato che non lo utilizzeremo in questo progetto.

<Aside type="tip">
Come vedi sopra, per ogni schema definito in Zod, esportiamo anche un'interfaccia usando la sintassi `z.TypeOf`. Questo converte la nostra definizione Zod in un'interfaccia TypeScript senza duplicare gli sforzi!
</Aside>

### Modellazione delle entit√†

Il diagramma ER per la nostra applicazione √® il seguente:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

Implementeremo il nostro database in DynamoDB utilizzando la libreria client [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) per semplificare il tutto. Per iniziare, installiamo `electrodb` eseguendo il comando:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Tutte le dipendenze vengono aggiunte al `package.json` principale poich√© `@aws/nx-plugin` segue il principio della [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Per maggiori informazioni, consulta la <Link path="guides/typescript-project#dependencies">guida ts#project</Link>.
</Aside>

Ora creiamo i seguenti file nella cartella `packages/game-api/src/entities` per definire le nostre entit√† ElectroDB secondo il diagramma ER sopra:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
</Tabs>

ElectroDB √® molto potente e ci permette non solo di definire i tipi, ma anche di fornire valori predefiniti per alcuni campi come i timestamp sopra. Inoltre, ElectroDB segue il [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), considerata la best practice con DynamoDB.

<Aside>
Sebbene ElectroDB supporti le [collections](https://electrodb.dev/en/modeling/collections/), in questo tutorial abbiamo scelto di non utilizzarle per semplicit√†.
</Aside>

### Aggiunta del client DynamoDB al contesto tRPC

Dato che abbiamo bisogno del client DynamoDB in ciascuna delle nostre procedure, vogliamo creare un'istanza unica del client da passare tramite contesto. Apporta queste modifiche in `packages/game-api/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Questo √® un plugin che strumentiamo per creare il `DynamoDBClient` e iniettarlo nel contesto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Estendiamo `IMiddlewareContext` per aggiungere `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Il plugin DynamoDB viene strumentato.

<Aside>
L'API `concat` associa il nostro middleware alle procedure definite. Per dettagli, consulta la [guida concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definizione delle procedure

Ora implementiamo i metodi API. Apporta queste modifiche in `packages/game-api/src/procedures`:

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `echo.ts` (da `packages/game-api/src/procedures`) dato che non lo useremo.

### Configurazione del router

Ora colleghiamo le procedure alla nostra API. Aggiorna il file come segue:

<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />

### Infrastruttura

L'ultimo passo √® aggiornare l'infrastruttura per creare la tabella DynamoDB e concedere i permessi alla Game API. Modifica `packages/infra/src` come segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Nota che ogni procedura √® gestita da una funzione lambda separata, permettendoci di applicare il principio del minimo privilegio assegnando solo i permessi necessari.
:::
  </TabItem>
</Tabs>

### Deployment e test

Prima compiliamo il codice:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Se incontri errori di linting, esegui questo comando per correggerli automaticamente:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Ora puoi deployare l'applicazione con:

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox']} />

Il primo deployment richieder√† circa 8 minuti. I successivi richiederanno circa 2 minuti.

:::tip
Per modifiche al codice lambda, puoi usare il flag `--hotswap` dopo la build per un deployment pi√π rapido (2-3 secondi):

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox --hotswap']} />
:::

<Drawer title="Comando di deployment" trigger="Puoi anche deployare tutti gli stack insieme. Clicca per dettagli.">

Puoi deployare tutti gli stack dell'applicazione CDK con:

<NxCommands commands={['run @dungeon-adventure/infra:deploy --all']} />

**Sconsigliato** se hai stack separati per ambienti (es. infra-prod), poich√© il flag `--all` tenter√† di deployarli tutti.

</Drawer>

Al termine del deployment, vedrai output simili a questi _(alcuni valori oscurati)_:

```bash
dungeon-adventure-infra-sandbox
dungeon-adventure-infra-sandbox: deploying... [2/2]

 ‚úÖ  dungeon-adventure-infra-sandbox

‚ú®  Tempo di deployment: 354s

Outputs:
dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX = dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY
dungeon-adventure-infra-sandbox.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-infra-sandbox.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Possiamo testare l'API:
<ul>
<li>Avviando un'istanza locale del backend tRPC e invocando le API con `curl`</li>
<li>
<Drawer title="Curl con Sigv4 abilitato" trigger="Chiamare l'API deployata usando curl con Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Aggiungi questo script al tuo `.bashrc` (e esegui `source`) o incollalo direttamente nel terminale:
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Esempi di utilizzo:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Aggiungi questa funzione al tuo profilo PowerShell o incollala nella sessione corrente:
```powershell
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Esempi di utilizzo:

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function url
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Locale">
    Avvia il server locale `game-api` con:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Usa il valore `dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX` dall'output del deploy CDK per sostituire il placeholder evidenziato.
    </Aside>

    Una volta avviato, invocalo con:
    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Deployato">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Usa il valore `dungeon-adventure-infra-sandbox.GameApiGameApiEndpointXXX` dall'output del deploy CDK e imposta la regione corretta.
    </Aside>
  </TabItem>
</Tabs>

:::note
Il parametro `%7B%7D` √® un oggetto JSON vuoto (`{}`) codificato URI.
:::

Se il comando ha successo, vedrai una risposta come:
```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Complimenti, hai costruito e deployato la tua prima API con tRPC! üéâüéâüéâ